# JS基础
## 01_JS基本用法
- js里的一切都是一种值， 只是值的类型不同。原始值， 或者变量， 常量
### JS的编写位置

```html
1.可以将js编写到网页内部的script标签

<script>

alert("哈哈！")

</script>



2.可以将js编写外部的js文件中，然后通过script标签进行引入

 <script src="./script/script.js"></script> 


3.可以将js代码编写到指定属性中

<button onclick="alert('你点我干嘛！')">点我一下</button>


<a href="javascript:alert(123);">超链接</a>  //其实就是放在url栏上
  
<a href="javascript:;">超链接</a>

```

### 字面量与变量

字面量

- 字面量其实就是一个值，它所代表的含义就是它字面的意思，相当于原始值

- 比如：1 2 3 4 100 "hello" true null .....

- 在js中所有的字面量都可以直接使用，但是直接使用字面量并不方便

变量

- 变量可以用“存储”字面量，变量储存字面量是js储存最小单位。还可以储存对象。

- 并且变量中存储的字面量可以随意的修改

- 通过变量可以对字面量进行描述，并且变量比较方便修改

```js
var/let/const tall = 80; //声明变量同时赋值变量同时定义变量名
let a;
a = 10  //先声明后赋值
```

### 变量的内存
![[Pasted image 20220924100108.png]]

- 原始值赋值的变量中并不存储任何值，而是存储值的内存地址！真正的值再另外开辟的内存空间里。
- 原始值的变量的更改其实更改是值的内存地址，换了一个值的内存地址，原来的值还在，别的变量还可以指向其地址，在内存中不会创建重复的原始值。如果没有变量指向，就会被回收。
- 所以存有相同原始值的变量的改变，不会影响另一个变量。（因为直接换了一个地址指向，原来的没变）

```js
let a = 10     //a 储存一个 10的 指向内存地址

let b = 10     //b 也储存一个 10 指向的内存地址     所以他们储存指向是同一个内存的地址

a = 12  //b 不会变

```

  
### 常量
- 在JS中，使用const声明常量，常量只能赋值一次，重复赋值会报错

- 在JS中除了常规的常量外，有一些对象类型的数据我们也会声明为常量

- 常量其实就是锁住了变量的内存地址的指向，让它只能指向一个内存地址。

```js
const PI = 3.1415926

 PI = 10  //会报错          

```

### 标识符
- 在JS中，所有可以由我们自主命名的内容，都可以认为是一个标识符，像 变量名 函数名 类名...

- 使用标识符需要遵循如下的命名规范：

1. 标识符只能含有字母、数字、下划线、$，且不能以数字开头

2. 标识符不能是JS中的关键字和保留字，也不建议使用内置的函数或类名作为变量名

3. 命名规范：

	- 通常会使用驼峰命名法

	- 首字母小写，每个单词开头大写

	- maxlength --> maxLength

	- borderleftwidth --> borderLeftWidth

  
4. 类名会使用大驼峰命名法

	- 首字母大写，每个单词开头大写

	- maxlength --> MaxLength

5. 常量的字母会全部大写，单词用_分开。（对象的常量一般还是小驼峰）

	- cosnt  MAX_LENGTH  = 10



## 02_数据类型
>原始数据类型包括：string 字符串；Number 数值；boolean 布尔值；null 空值；undefined 未定义；引用数据类型：object 对象

### 数值（Number）

- 在JS中所有的整数和浮点数都是Number类型

- JS中的数值并不是无限大的，当数值超过一定范围后(2^52)会显示近似值

- 因为JS是二进制运算，所以运算小数会不精确

- Infinity 是一个特殊的数值表示无穷（没有意义一般不用）

- NaN 也是一个特殊的数值，表示非法的数值

- 其他进制的数字：

	- 二进制 0b   (a = 0b1010)

	- 八进制 0o  (a = 0o10)

	- 十六进制 0x (a = 0xff)


### 大整数（BigInt）

- 大整数用来表示一些比较大的整数
- 大整数使用n结尾，它可以表示的数字范围是无限大(以内存为依据)


### 字符串（String）
- 在JS中使用单引号或双引号来表示字符串。
- 传统字符串不能换行，不能嵌入变量。
- 转义字符  \   - 当字符串里面有一些特殊字符，比如 " 引号 会和字符串的 ” 混淆，所以用\ " 表示引号
	\" --> "
	\t --> 制表符(缩进)
	\n --> 换行
	
- 模板字符串

	- 使用反单引号来表示模板字符串

	- 模板字符串中可以嵌入变量`我是${变量}`

	- 使用typeof检查一个字符串时会返回 "string"

### 其他数据类型

- 布尔值（Boolean）

	- 布尔值主要用来进行逻辑判断
	- 布尔值只有两个true 和 false
	- 使用typeof检查一个布尔值时会返回 "boolean"


- 空值 （Null）

	- 空值用来表示空对象,   =>''空字符串还是字符串
	- 空值只有一个 null
	- 使用typeof检查一个空值时会返回"object"
	- 使用typeof无法检查空值

  
- 未定义（Undefined）

	- 当声明一个变量而没有赋值时，它的值就是Undefined
	- Undefined类型的值只有一个就是 undefined
	- 使用typeof检查一个Undefined类型的值时，会返回 "undefined"

- 符号（Symbol）

	- 用来创建一个唯一的标识  let c = Symbol() // 调用Symbol()创建了一个符号
	- 使用typeof检查符号时会返回 "symbol"


>JS中原始值一共有七种   1.Number   2.BigInt   3.String   4.Boolean   5.Null   6.Undefined   7.Symbol
七种原始值是==构成各种数据的基石，是js的最小单位==原始值在JS中是不可变类型，一旦创建就不能修改。
其含义是：原始值的变量更改其实是更改的内存地址，因为其真正的值，不能被修改。

### 数据类型检查 （Typeof）

typeof 运算符

- typeof 用来检查不同的值的类型，所有值的类型都逃不过原始数据类型，注意null数据类型的返回值是错的。

- 它会根据不同的值返回不同的结果，返回的是一个字符串

```js
let a = 10
let b = 10n

console.log(typeof a) // "number"

console.log(typeof b) // "bigint"


```

### 类型转换-字符串
==所谓类型转换，就是不是将一个数据类型变为另一个数据类型，而是根据一个值，创建了一个新的数据类型的值。==
1.调用toString()方法

--> xxx.yyy()
- 变量调用toString方法返回的是一个变量的字符串，需要再赋值给原变量才能使用。所以变量其实是换了一个值，把原值换成了类型为字符串的值。（参考变量的内存）
- 由于null和undefined中没有toString()方法，所以对这两个东西调用toString()时会报错。


2.调用String()函数

--> yyy(xxx)

- 对于拥有toString()方法的值调用String()函数时，实际上就是在调用toString()方法。相当于中间商。

- 对于null，则直接转换为"null"；对于undefined，直接转换为"undefined"。


### 类型转换-数值

1. 使用Number()函数来将其他类型转换为数值

- 字符串：

	- 如果字符串是一个合法的数字，则会自动转换为对应的数字

	- 如果字符串不是合法数字（11xx），则转换为NaN

	- 如果字符串是空串或纯空格的字符串，则转换为0

- 布尔值：

	- true转换为1，false转换为0

- null：
	- 转换为 0

- undefined：
	- 转换为 NaN

2. parseInt()函数 —— 将一个字符串转换为一个整数

	- 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数（'xx111'，这样不行）

	- 也可以使用parseInt()来对一个数字进行取整(不推荐，因为数字要先转字符串再转换成数字)

3. parseFloat()函数 —— 将一个字符串转换为浮点数（转换带小数）

	- 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的小数



### 类型转换-布尔值

1. 使用Boolean()函数来将其他类型转换为布尔值

- 数字：

	- 0 和 NaN 转换为false
	- 其余是true

- 字符串：

	- 空串 转换为 false
	- 其余是true

- null和undefined 都转换为 false

- 对象：对象会转换为true

>所有表示空性的没有的错误的值都会转换为false：0、NaN、空串、null、undefined、false


## 03_运算符（操作符）
- 运算符可以用来对一个或多个操作数（值）进行运算

### 算术运算符

+ 加法运算符  a = 1 + 1

- 减法运算符  a = 10 - 5

* 乘法运算符   a = 2 * 4

/ 除法运算符   a = 10 / 5 ；a = 10 / 0 // Infinity

** 幂运算  a = 10 ** 4 ； a = 9 ** .5 // 开方

% 模运算，两个数相除取余数  a = 10 % 4


==注意：
- JS是一门弱类型语言，当进行运算时会通过自动的类型转换来完成运算

- 算术运算时，除了字符串的加法，其他数据类型做运算时候，都会转换为数值然后再运算。

```js
a = 10 - '5' // 10 - 5

a = 10 + true // 10 + 1

a = 5 + null // 5 + 0

a = 6 - undefined // 6 - NaN
```

- 当任意一个值和字符串做加法运算时，它会先将其他值转换为字符串，然后再做拼串的操作
- 其原理和String()函数相同，但使用起来更加简洁

> 转换为字符串  显式转换:  String(a)   ||    隐式转换:  a + ""

```js

a = hello + 'world' // helloworld

a = '1' + 2 // "1" + "2"  => 12

a = a + '' // a

```

### 赋值运算符

>赋值运算符用来将一个值赋值给一个变量

- = —— 赋值，将符号右侧的值赋值给左侧的变量 

- ??= —— 空赋值，只有当变量的值为null或undefined时才会对变量进行赋值

```js
a = null
a ??= 101   //可以少一个if 判断变量是否为空再赋值
``` 

- += ——  a += n 等价于 a = a  +  n

- -= —— a -= n 等价于 a = a  -  n

- * = —— a  * = n 等价于 a = a * n

- /= ——  a /= n 等价于 a = a / n

- %= —— a %= n 等价于 a = a % n

- * * = —— a * * = n 等价于 a = a * * n

### 一元的±
+ 正号

	- 不会改变数值的符号

- 负号

	- 可以对数值进行符号位取反

`除了字符串的加运算，其他类型的算术运算都会先将其转换为数值然后再运算。
`所以可以实现字符串的快速转换为数值类型。

 >转换为数值    显式转换:  Number(b)   ||    隐式转换:  +b
 
```js
let a = -10

a = -a

let b = '123'

b = +b // b = Number(b)  快速转换成了数值类型
```

### 自增和自减
>自增自减运算，比较特殊，可以不用赋值让变量变化，而且是立刻变化。前后自增只是区分返回的新旧值。
- ++ 自增运算符

	- ++ 使用后会使得原来的变量立刻增加1

	- 自增分为前自增(++a)和后自增(a++)

	- 不同的是++a和a++所返回的值不同

	- a++ 返回的值是自增前的值 旧值   ||  ++a 返回的值是自增后的值 新值

```js
let n = 5

let result = n++ + ++n + n   // 5 + 7 + 7  （n++返回的是旧值5， ++n返回的新值7）
```
- -- 自减运算符

	- 使用后会使得原来的变量立刻减小1

	- 自减分为前自减(--a)和后自减(a--)

	- 不同的是--a和a--返回的值不同  --a 是新值  ||   a-- 是旧值


### 逻辑运算符

> 逻辑运算的非布尔值运算虽然在运算时转化为布尔值，但是返回值还是返回原值。

1. ! 逻辑非

	- 它可以对一个布尔值进行取反操作    true --> false;     false --> true

	- 如果对一个非布尔值进行取反，它会先将其转换为布尔值然后再取反
	
>   转换为布尔值  显式转换:   Boolean(a)   ||    隐式转换   !!a

2. && 逻辑与

	- 对于布尔值运算，当&&左右都为true时，则返回true，否则返回false   
	- 与运算是找false的，如果找到false则直接返回，没有false才会返回true。
	
	- 对于非布尔值进行与运算，它会转换为布尔值然后运算，然后同样是找false，第一个是false直接返回第一个值，否则直接返回第二值。（因为第二个值不管是什么都要返回第二个）

	```js
	let result = true && true // true

	result = true && false // false

	result = 1 && 2 // 2

	// true && false -> false

	result = 1 && 0 // 0
	
	```


3. || 逻辑或

	- 对于布尔值运算，有true就返回，没有true就返回false
	- 或运算是找true，如果找到true则直接返回，没有true才会返回false

	- 对于非布尔值或运算，它会转换为布尔值然后运算，但是最终会返回原值
	- 如果第一个值为true，则返回第一个，如果第一个值为false，则返回第二个。

	```js

	result = true || false // true

	result = false || true // true

	result = true || true // true

	result = 1 || 2 // 1

	result = "hello" || NaN // "hello"

	result = NaN || 1 // 1

	result = NaN || null // null
	```



string字符串的对象方法

1，字符串底层以数组的方式储存，所以可以用数组的方法/属性调用。如：str.length

str.trim() --可以去掉字符串前后空字符

str.charAt(根据索引返回字符);

str.charCodeAt(根据索引返回Unicode编码);

str.indexOf(查找是否有某个字符并返回第一次出现的索引值，查找起始索引);

str.lastIndexOf(查找最后出现的位置的字符，查找结束索引);

str.slice(1,2); --和数组方法用法一样

str.split(根据一个字符串拆分如：",");--如果为空""则每个字符都拆分。 --可以用正则 而且默认全局

str.search();搜索字符串中有某个字符没有，并返回第一次出现的索引。 --可以用正则 但是不能全局，只能查找第一个

str.match();可以根据正则，提出出来字符。默认只只找一个，可以设置规则模式，全局g， 或者ig，--可以用正则

str.replace("a","@");可以将指定内容替换，"a"被替换内容 "@"新的内容 --可以用正则

### 关系运算符

- 关系运算符用来检查两个值之是否成立。成立返回true，不成立返回false，而且只能返回布尔值。

- > 用来检查左值是否大于右值

- >=用来检查左值是否大于或等于右值

- <用来检查左值是否小于右值

- <=用来检查左值是否小于或等于右值

```js
// 检查num是否在5和10之间

let num = 4

// result = 5 < num < 10 // 错误的写法

result = num > 5 && num < 10
```

- 注意：

	- 当对非数值进行关系运算时，它会先将前转换为数值然后再比较。
	```js
	result = 5 < "10" // true

	result = "1" > false // true
	```
	- 当对两个字符串关系运算时（一个还是正常的），它不会将字符串转换为数值，而是逐位的比较字符的Unicode编码。`利用这个特点可以对字符串按照字母排序
	```js
	//注意比较两个字符串格式的数字时一定要进行类型转换
	result = +"12" < "2" // false
  
	```
	
### 相等运算符
- ==

	- 相等运算符，用来比较两个值是否相等
	- 比较两个不同类型的值时，它会将其转换为相同的类型（通常转换为数值）然后再比较
	- 类型转换后值相同也会返回true
	- null和undefined进行相等比较时会返回true
	- NaN不和任何值相等，包括它自身， 可以用 isNaN()的函数，来判定NaN是否存在

- ===

	- 全等运算符，用来比较两个值是否全等
	- 它不会进行自动的类型转换，如果两个值的类型不同直接返回false
	- null和undefined进行全等比较时会返回false

- !=

	- 不等，用来检查两个值是否不相等
	- 会自动的进行类型转换

- !==

	- 不全等，比较两个值是否不全等
	- 不和自动的类型转换
  

### 条件运算符

- 条件表达式 ? 表达式1 : 表达式2

- 执行顺序：`MAX = a > b ? alert("a大") ：alert("a小"); MAX = MAX > c ? max : c

条件运算符在执行时，会先对条件表达式进行求值判断，

如果结果为true，则执行表达式1；如果结果为false，则执行表达式2

### 运算符的优先级

- 可以通过优先级的表格来查询运算符的优先级

[优先级表格](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

- 在表格中位置越靠上的优先级越高，优先级越高越先执行，优先级同一级别的自左向右执行

- ()拥有最高的优先级，使用运算符时，如果遇到拿不准的，可以直接通过()来改变优先级即可

### in 运算符

- 用来检查对象中是否含有某个属性（检查的是整个原型链）
- 语法 属性名 in obj
- 如果有返回true，没有返回false
```js
console.log("name" in obj)  //返回布尔值
```

## 04_流程控制
流程控制语句可以用来改变程序执行的顺序
1.条件判断语句   2.条件分支语句   3.循环语句

### 代码块
>使用 {} 来创建代码块，代码块可以用来对代码进行分组
同一个代码中的代码，就是同一组代码，一个代码块中的代码要么都执行要么都不执行

- let 和 var

- 在JS中，使用let声明的变量具有块作用域：在代码块中声明的变量无法在代码块的外部访问，但是能够被子作用域访问到，但是父作用域不能访问子作用域的变量。
```js
{

let a = 10

{
let b = 20
console.log(a) //可以得到变量a
}
console.log(b) //不可以得到变量b
}

console.log(a) //不可以得到变量a
```

- 使用var声明的变量，不具有块作用域，var声明的相当于全局变量，不容易维护。

### 条件语句
1. if语句语法：

```js

if(条件表达式){

语句；

}else{

语句；
}

```

- 执行流程

	- if语句在执行会先对if后的条件表达式进行求值判断，如果结果为true，则执行if后的语句，如果为false则不执行，直接进入else语句。
	
	- if语句只会控制紧随其后其后的那一行代码，如果希望可以控制多行代码，可以使用{}将语句扩起来

	- 如果if后的添加表达式不是布尔值，会转换为布尔值然后再运算

2. if-else语句语法：

```js

//条件表达式只会执行一个代码块，不管是if，还是else if 还是else， 一切看谁先判定

if(条件表达式){

语句...

}else if(条件表达式){

语句...

}else if(条件表达式){

语句...

}else if(条件表达式){

语句...

}else{

语句...

}
```

- 执行流程：

	- if-else if-else语句，会自上向下依次对if后的条件表达式进行求值判断，

	- 如果条件表达式结果为true，则执行当前if后的语句，执行完毕语句结束。

	- 如果条件表达式结果为false，则继续向下判断，直到找到true为止

	- 如果所有的条件表达式都是false，则执行else后的语句

- 注意：

	- if-else if-else语句中只会有一个代码块被执行， 一旦有执行的代码块，下边的条件都不会在继续判断了

3. switch语句语法：

>switch语句就是为了简化if-else语句，但是也会有些不同。

```js
switch(表达式){

case 表达式:

代码...

break

case 表达式:

代码...

break

case 表达式:

代码...

break

default:

代码...

break

}

```

- 执行的流程

	- switch语句在执行时，会依次将switch后的表达式和case后的表达式进行全等比较
	- 如果比较结果为true，则==自当前case处开始执行代码==
	- 如果比较结果为false，则继续比较其他case后的表达式，直到找到true为止
	- 如果所有的比较都是false，则执行default后的语句(这个default其实if语句也能用)

- 注意：

	- 一旦case判定为true，只要是当前case后的代码，都会执行
	- 可以使用break来避免执行其他的case。

>总结
switch语句和if语句的功能是重复，理论上可以会互相替换。但也有些不同：1. switch主要做全等判断 2. 当判定成功，case后的代码都会执行 

### 循环语句
 - 通过循环语句可以使指定的代码反复执行
 - JS中一共有三种循环语句，while语句；do-while语句；for语句。

1. while语句

- 语法：

	```js
	while(条件表达式){

	语句...

	}
  
	```

- 执行流程：

	- while语句在执行时，会先对条件表达式循环进行判断。
	- 如果结果为true，则执行循环体，执行完毕，继续判断，如此重复，直到条件表达式结果为false时，循环结束。
	- 当一个循环的条件表达式恒为true时，这个循环就是一个死循环，会一直执行（慎用）
	- 但是break也可以的停止循环，所以也可以在循环体中判断条件表达式，用break结束循环。

- 编写一个循环，要有三个要件:

	1.初始化表达式（初始化变量）let i=1;
	2.条件表达式（设置循环运行的条件）while(i<10)
	3.更新表达式（修改初始化变量） i++ 

2. do-while语句

- 语法：
	```js
	
	do{

	语句...

	}while(条件表达式)

```

- 执行顺序：
	- do-while语句在执行时，会先执行do后的循环体。
	- 执行完毕后，会对while后的条件表达式进行判断。
	- 如果为false，则循环终止；如果为true，则继续执行循环体，以此类推。


- 和while的区别：
	- while语句是先判断再执行。
	- do-while语句是先执行再判断，do-while语句可以确保循环至少执行一次（其实就是第一次不判断直接执行，第二次才开始判断）。

3. for语句

  >for循环和while没有本质区别，都是用来反复执行代码；不同点就是语法结构，for循环更加清晰

- 语法：
```js
for(初始化表达式; 条件表达式; 更新表达式){   

语句...

}

let i = 0   for(;i < 5;)   { console.log(i) i++  }
```

- 执行流程：
	-  执行初始化表达式，初始化变量
	-  执行条件表达式，判断循环是否执行（true执行，false终止）
	-  判断结果为true，则执行循环体
	- 执行更新表达式，对初始化变量进行修改
	- 重复执行，知道判断为false为止

- 注意：
	- 初始化表达式，在循环的整个的生命周期中只会执行1次
	- for循环中的三个表达式都可以省略
	- 使用let在for循环的()中声明的变量是局部变量，只能在for循环内部访问
	- 使用var在for循环的()中声明的变量可以在for循环的外部访问

- 创建死循环的方式：
	1. while(1){}
	2. for(;;){}
  
### break和continue

- break

	- break用来终止switch和循环语句，if不能用，除非if在一个循环里。
	- break执行后，当前的switch或循环会立刻停止，终止离他最近的循环

- continue

	- continue用来跳过当次循环

## 05_对象

>对象是JS中的一种复合数据类型，可以保存多个数据类型的变量。它相当于一个容器，在对象中可以存储各种不同类型数据。也就是说可以储存不同基本数据类型的变量（属性）

对象的分类：
1. 内建对象
	- 由ES标准所定义的对象
	- 比如 Object Function String Number ....

2. 宿主对象
	- 由浏览器提供的对象
	- BOM、DOM

3. 自定义对象
	- 由开发人员自己创建的对象

创建对象：
1. let obj = new Object(); 
2. obj = Object()     
3. 字面量形式创建 obj ={}  

向对象中添加属性：对象.属性名 = 属性值 （修改同理）

读取对象中的属性：对象.属性名  （没有属性会报undefined）

删除对象中的属性：delete 对象.属性名

### 对象的属性
>对象的属性其实就是基本数据类型赋值的变量，只是储存在了对象这个容器中，作为其属性存在。
- 属性名

	- 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求 obj.let = "属性名任意值"
	- 属性名有些特殊字符的时候要用 `[]` 来设置  `obj["1231312@#@!#!#!"]` 记得要添加引号变成字符串
	- 可以把符号（symbol）赋值的变量作为属性名，获取这个属性时，也必须使用同一个赋值的变量。
	- 属性名可以是变量，但是也需要用`[]` 来设置  `obj[mySymbol] = "通过symbol添加的属性"`

	```js
	
	let str = "address"

	obj[str] = "花果山" // 等价于 obj["address"] = "花果山"
	
	obj["gender"] = "男" //等价于 obj.gender = "男"

	```

属性值

- 对象的属性值可以是任意的数据类型，也可以是一个对象或者函数。
- 当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法。调用函数就称为调用对象的方法。

### 对象的遍历（枚举）
>枚举属性，指将对象中的所有的属性全部获取，获取属性后同样可以获取属性值。

for-in语句

- 语法：
```js

let obj = {

name:'孙悟空',

age:18,

gender:"男",

address:"花果山",

[Symbol()]:"测试的属性" // 符号添加的属性是不能枚举

}

  

for(let propName in obj){ 

console.log(propName, obj[propName])      //获取当前枚举的属性名，同时获取当前枚举的属性值

//注意： propName就是一个变量，只能存一个值，每次遍历都只存当前变量的属性名。可以再次追加进数值里，得到全部的。值也同理。

}

```

- for-in的循环体会执行多次，有几个属性就会执行几次，但是有些属性不能遍历。
- 每次执行时，都会将一个属性名赋值给我们所定义的变量


Object.keys 方法

```js
Object.keys(data) //遍历对象 并返回对象的key， 在数组中
```
### 对象的解构赋值
>对象的解构赋值就是把对象的属性值结构出来，赋值给新变量。
- 语法： {属性1:变量名1，属性2:变量名2} = {属性1：值1， 属性2：值2}
```js
const obj = { name: "孙悟空", age: 18, gender: "男" }

let { name, age, gender } = obj // 声明变量同时解构对象,
  

let name, age, gender;
({ name:name, age:age, gender:genger } = obj)   //先声明后结构，防止js误解析{}为代码块，需要添加括号


let { address } = obj // 没有的属性返回undefined
  

let {name:a, age:b, gender:c, address:d="花果山"} = obj  //自定义变量名，也可以同时添加默认值
```
### 对象的内存 
![[Pasted image 20220924100543.png]]
- 对象属于可变类型，意思是可以任意的添加删除修改对象中的属性。 ^01
- 原因在于对象同样单独开辟了一个内存空间，对象赋值的变量其实存放的是对象的内存地址。当修改对象里面的属性时，这个内存地址不会改变。

- 当对两个对象进行相等或全等比较时，其实比较的是对象的内存地址
- 如果有两个变量同时指向一个对象，通过一个变量修改对象的属性时，对另外一个变量也会产生影响
- 原因在于，这两个变量指向的是一个对象的内存地址。
```js
let obj = Object()

let obj4 = obj

obj4.name = "猪八戒" // 当修改一个对象时，所有指向该对象的变量都会收到影响
```

注意： 对象里面的属性：如果存放原始值，那么还是存放的原始值的内存地址，如果存的是对象，那么也是存放的对象的内存地址。解构下来就是，原始值永远独立的存放在单独开辟的内存中，也就是栈内存中。

### 修改对象与属性

1. 修改对象的原理

	- 修改对象时，其实是修改对象指向内存地址，当指向的内存地址修改后，就不会影响到原来的哪个地址的对象。（跟基本数据类型相似，==对象也可以是说不可变的，可变的是其中的属性==）
	```js
	const obj = {

	name: "孙悟空",

	}
	const obj2 = obj

	// obj2 = {} 

	obj2.name = "猪八戒" // 修改对象，影响其他变量
	```
	- 但是当一个变量重新指向了其他对象，就不会影响其他对象。因为这个两个变量指向不同对象的地址。
	```js
	const obj = {

	name: "孙悟空",

	}
	const obj2 = obj

	 obj2 = {} 

	obj2.name = "猪八戒" // 修改对象，不影响其他变量
	```

==注意：
在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明存储对象的变量时会使用const，const只是禁止变量被重新赋值，对对象的修改没有任何影响

1. 修改属性的原理（其实就是原始值的变量的修改）

	- 修改属性时，其实就是修改对象里面存的变量，当变量的值改变，变量指向的内存地址也发生改变。但是包含它的哪个对象，还是没发生改变，因为对象的内存地址指向没变，变的是其属性的地址指向。
	```js
	obj3.name = "沙和尚"   //
	```
  
### 垃圾回收（Garbage collection）
- 在程序的世界中，什么是垃圾？
- 如果一个对象没有任何的变量对其进行引用，那么这个对象就是一个垃圾
- 垃圾对象的存在，会严重的影响程序的性能

- 在JS中有自动的垃圾回收机制，这些垃圾对象会被解释器自动回收，我们无需手动处理
- 对于垃圾回收来说，我们唯一能做的事情就是将不再使用的变量设置为null

## 06_函数
>函数就是一个可以存储代码一个对象，它具有其他对象所有的功能，同时调用可以执行里面的代码。

语法：
```js
//创建函数
function 函数名(){

语句...

}

//调用函数
//可以执行函数中存储的代码
//可以得到函数体里返回的数据

函数名()  
```

### 函数的创建方式

1. 函数声明
```js
function 函数名([参数]){

语句...

}
```


2. 函数表达式（匿名函数）

```js
const Fun = function([参数]){    //匿名函数，必须赋值，不然函数提升不了，就会报错。不赋值的匿名函数可以加括号变为立即执行函数。

语句...

}
```

3. 箭头函数

```js
const Fun = ([参数]) => {    //当只有一个参数时，括号可以省略 

语句...

}

```

### 函数的参数

1. 形式参数

	- 在定义函数时，可以在函数中指定数量不等的形式参数（形参）
	- 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

2. 实际参数

	- 在调用函数时，可以在函数的()传递数量不等的实参
	- 实参会赋值给其对应的形参

- 传参规则：

	1. 如果实参和形参数量相同，则对应的实参赋值给对应的形参
	2. 如果实参多余形参，则多余的实参不会使用
	3. 如果形参多余实参，则多余的形参为undefined

- 参数的默认值
```js
// 定义参数时，可以为参数指定默认值

// 默认值，会在没有对应实参时生效

const fn3 = (a=10, b=20, c=30) => {

console.log("a =", a);

console.log("b =", b);

console.log("c =", c);

}
fn3()  // 10, 20, 30
```

- 参数的类型
- JS中不会检查参数的类型，可以传递任何类型的值作为参数

- 对象作为参数
- 因为参数其实就是变量，逻辑和变量赋值一样，当对象作为参数时，其实就是对象赋值变量。

```js
//  传递实参时，传递并不是变量本身，而是变量中存储的值

// 1.当以实参传递对象时

function fn(a){

a.name = "猪八戒" // 可以修改全局对象的值，因为对象赋值给实参，实参和对象指向同一个地址。

console.log(a)

}
let obj = { name: 'shao'}
fn(obj)

// 2. 当以默认值传递对象时
function fn(a = { name: 'shao'}){

a.name = "猪八戒" 

console.log(a)

}
fn() // 函数每次调用，都会重新创建默认值, 因为参数等于变量，又再块作用域中，块作用域的代码执行完毕就会立刻销毁，所以每次调用都是新的函数。
```

- 函数作为参数
- 在JS中，函数也是一个对象（一等函数）别的对象能做的事情，函数也可以
- 函数传参，其实就是把一个函数里面的代码传给另一个函数。
```js

function fn(a){

console.log("a =", a)

// a()

}
  
function fn2(){

console.log("我是fn2")

}

 fn(fn2)     //把一个函数作为参数传给形参，在另一个函数中可以调用它。

fn(()=>console.log("我是箭头函数"))  //把一个箭头函数传参给形参，可以可以直接调用它。
```
#### 剩余参数
1. 动态参数-arguments
	- arguments是函数中又一个隐含参数，另一个是this
	- arguments是一个类数组对象（伪数组）

- 和数组相似，可以通过索引来读取元素，也可以通过for-of循环变量，但是它不是一个数组对象，不能调用数组的方法
- arguments用来存储函数的实参，无论用户是否定义形参，实参都会存储到arguments对象中，可以通过该对象直接访问实参。
```js
function fn() {console.log(arguments[2])}//类数组对象，通过索引访问
fn(1,2,3,4)
```
2. 剩余参数/可变参数-...abc
	- 可变参数可以接收任意数量实参，并将他们统一存储到一个数组中返回
	- 可变参数的作用和arguments基本是一致，但是也具有一些不同点：
		1. 可变参数的名字可以自己指定
		2. 可变参数就是一个数组，可以直接使用数组的方法
		3. 可变参数接收的是没有定义的实参，也就是剩余的实参，可以和定义的实参一起使用。
```js
function fn3(a, b, ...args) { 
//当可变参数和普通参数一起使用时，需要将可变参数写到最后

console.log(args) //接收的是没有定义形参时实参。

}


fn3(123, 456, "hello", true, "1111")
```

### 函数的返回值

>函数里面主要存放代码，但是代码的执行结果也需要返回出来。可以通过return关键字来指定函数的返回值。函数调用完毕返回值便会作为结果返回。

- 任何值都可以作为返回值使用（包括对象和函数之类）
- 如果return后不跟任何值，则相当于返回undefined
- 如果不写return，那么函数的返回值依然是undefined

```js
let res =  function fn(a, b) {

return a + b     //返回一个值
}
console.log(res)  //打印返回的值
```

- return一执行函数立即结束
```js
function fn() {
  
alert(123)

return       //就不会执行下面的代码

alert(456)

}
```

- 箭头函数的返回值
- 函数的返回值都应该用 return ，但是当箭头函数里的代码只有一行时，可以不用写return，可以直接写在箭头后，就可以自动返回返回值。
```js
const sum = (a, b) => a + b  //只有一行代码时，就可以自动返回值
const fn = () => ({name:"孙悟空"})   //如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来.因为js分不出大括号是对象。
```

### 作用域
>作用域指的是一个变量的可见区域

1. 全局作用域
	- 全局作用域在网页运行时创建，在网页关闭时消耗
	- 所有直接编写到script标签中的代码都位于全局作用域中
	- 全局作用域中的变量是全局变量，可以在任意位置访问

2. 局部作用域
	- 块作用域
		- 块作用域是一种局部作用域
		- 块作用域在代码块执行时创建，代码块执行完毕它就销毁
		- 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问。（var除外）

	```js
	{      //块作用域，块内部可以访问外部，外部不能访问内部。作用域是从内到外访问。
	let b = "变量b"
		{
			{
			console.log(b)
			}
		}
	}
	```
	
	- 函数作用域
		- 函数作用域也是一种局部作用域
		- 函数作用域在函数调用时产生，调用结束后销毁
		- 函数每次调用都会产生一个全新的函数作用域，也是每次调用函数都会重置的原因。
		- 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问
	```js

	function fn(){

	let a = "fn中的变量a"

	console.log(a)   //内部可以访问到，外部访问不到。和块作用域一样
	}

	fn()

	console.log(a)
	```
3. 作用域链
- 局部作用域，与全局作用域的规则就是由内到外一层一层查找。如果找到了则直接使用，如果没找到，则去上一层作用域中寻找，找到了则使用。以此类推，直到报错。
- 当我们使用一个变量时，JS解释器会优先在当前作用域中寻找变量，当全局和当前变量一样时，就近原则，先用当前作用域的。

### window对象
- 浏览器把JS封装了一个window对象；里面存放着关于浏览器的属性和方法。所以整个js就是一个window对象。
- window对象初始存储JS中的内置对象（String(); Number() ）和浏览器的宿主对象——JS运行环境提供的对象DOM-BOM对象(console.log; alert() )
- window对象的属性和方法可以通过window对象访问，console.log(); alert()这些都是window对象的方法和
   属性。自定义在全局作用域的函数和变量，等于window对象的方法和属性。（let好像除外）

```js
	window.alert(123)  //window的方法

	window.console.log("哈哈")  //window的console对象里面的log方法
	
	window.a = 10 // 向window对象中添加的属性会自动成为全局变量。
```

- var 不具有块作用域，在全局和块作用域中声明的变量，都会成为window的属性。
- var虽然没有块作用域，但有函数作用域，在函数里面声明不会变为全局变量也就是window的属性。
- let 自带块作用域，在全局中声明的变量，也不会成为window对象的属性。
- 使用function声明的函数，都会作为window的方法保存

==注意：
```js
function fn2(){

d = 10 // 在局部作用域中，如果没有使用var或let声明变量，则变量会自动成为window对象的属性 也就是全局变量

}

fn2()
```

### 函数提升
>为什么会有变量提升？ 因为为了提前计算分配内存，提前把变量的数量统计一下，预留好空间。

- 变量的提升
	- 使用var声明的变量，它会在所在作用域执行前被声明，所以我们可以在变量声明前就访问变量，但是因为没有赋值，所以没有什么用。
	- let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问。

- 函数的提升

	- 使用函数声明（function）创建的函数，会在其他代码执行前被创建，然后等待被调用。所以我们可以在函数声明前调用函数。

  
### 立即执行函数
- 在开发中应该尽量减少直接在全局作用域中编写代码！所以要避免用var，因为块作用域里它也会变为全局。
- 所以我们的代码要尽量编写的局部作用域，如果使用let声明的变量，可以使用{}来创建块作用域，var的话，就要写在函数作用域里。

- 立即执行函数（IIFE）
	- 立即是一个匿名的函数，并它只会调用一次（估计因为没有名字，没法再次调用，只能执行一次）
	- 因为匿名，所以不能函数提升，函数提升需要名字，所以要在函数声明外加括号不让它提升。
	- 立即执行函数相当于创建了一个函数作用域，包括一部分代码，防止变量全局污染，
	- 其实立即执行函数还是window调用的。

```js
(function(){

let a = 10

console.log(111)

}());        //两个立即执行函数在一起，要记得加分号， 或者中间有其他代码，不然会被js误解释。

  

(function(){

let a = 20

console.log(222)

}())
```

### 函数的this
- 函数创建出来是必须要执行时，所以它总会有一个对象来调用它。
- JS解析器每次函数调用都会传递进一个隐含的实参，这个参数就叫做 this。
- this会指向直接调用它的一个对象。通过this可以在方法中引用调用方法的对象。

==以函数的调用方式区分：==
1. 以函数形式调用时，其实全局的函数调用就是window的方法，所以this指向的是window
```js
function fn() {
// console.log(this === window)
console.log("fn打印", this)

}
 fn() // window.fn()   函数的形式调用，永远指向window

```
2. 在函数中调用函数时，只要是以函数的形式调用，被调用的函数this就指向window；但是函数里面的函数调用，是谁的方法呢。
```js
let res = {

name: '123',

f2: function (){

		let a = 10

			function f1(){

				let a = 10

				console.log(this)

				};

		f1()      //当在函数中调用函数时，不管最外层是哪个对象调用， 只要直接调用的方式是函数的形式，就永远指向window
		}
}
res.f2()
```
3. 以对象方法的形式调用时，this指向的是调用方法的对象

 ==箭头函数的this==
	- 箭头函数没有自己的this，它的this由最近一层的作用域决定。定义箭头函数的上层对象的this，就是它的this（只是最近一层）
	- 箭头函数的this和它的调用方式无关，只与它定义时的外层作用域有关，所以箭头函数的this是固定的。一出生就注定了。
```js
const obj = {

name:"孙悟空",
sayHello(){

		const t2 = () => {

			console.log("t2 -->", this)   //这里因为t2的外层是obj的方法，此方法的this就是obj，所以t2的this也是obj。
									
			}
		}
		t2()
}


```
==注意：==
>当箭头函数的上层是作用域是一个对象时，它的this是window

### call/apply/bind
- 根据函数调用方式的不同，this的值也不同：
	1. 以函数形式调用，this是window
	2. 以方法形式调用，this是调用方法的对象
	3. 构造函数中，this是新建的对象
	4. 箭头函数没有自己的this，由外层作用域决定
	5. 通过call和apply调用的函数，它们的第一个参数就是函数的this
	6. 通过bind返回的函数，this由bind第一个参数决定（无法修改）

- 通过调用函数的call()和apply()方法来改变this的指向
- call 和 apply方法调用的同时，也会直接调用函数本身。
1. 函数.call()
	- call的第一个参数，将会成为函数的this
	- 通过call方法调用函数，实参要写在第一个参数后面。
```js
 fn2.call(obj, "hello", true)
```
2. 函数.apply()
	- apply的第一个参数，将会成为函数的this
	- 通过apply方法调用函数，函数的实参需要通过一个数组传递
```js
fn2.apply(obj, ["hello", true])
```
3. 函数.bind()
	- bind() 是函数的方法，可以用来创建一个新的函数
	- bind的第一个参数，成为新函数的this
	- bind第一个参数后面的参数，绑定新函数的形参
```js
function fn(a, b, c) {  
console.log("fn执行了~~~~", this)
console.log(a, b, c)
}

const obj = {name:"孙悟空"}

const newFn = fn.bind(obj, 10, 20, 30)  //函数的方法创建新函数，第一个参数是新函数newFn的this，后面的实参，绑定了形参，a, b, c不能修改


 newFn()  //执行新函数
```
==注意==
>箭头函数没有自身的this，它的this由外层作用域决定，也无法通过call apply 和 bind修改它的this。箭头函数中没有arguments。

### 严格模式
- JS运行代码的模式有两种：

- 正常模式
	- 默认情况下代码都运行在正常模式中
	- 在正常模式，语法检查并不严格，它的原则是：能不报错的地方尽量不报错
	- 这种处理方式导致代码的运行性能较差，比如不声明变量就不会变量提升，导致不能提前预留空间。

- 严格模式
- 在严格模式下，语法检查变得严格: 必须命名变量，变量名只能命名一次。
1.禁止一些语法；2.更容易报错；3.提升了性能

```js
"use strict" // 全局的严格模式

let a = 10

function fn(){

"use strict" // 函数的严格的模式

}
```

### 高阶函数
>一个函数的参数也可以是函数，如果将函数作为参数传递，那么我们就称这个函数为==回调函数==（callback）
如果一个函数的参数或返回值是函数，则这个函数就称为==高阶函数==
- 用法一：
- 将函数作为参数，意味着可以对另一个函数动态的传递代码
```js

function filter(arr, cb) {   //其中 arr是要操作的数组， cb是回调函数，作为参数传给了filter

const newArr = []

for (let i = 0; i < arr.length; i++) {

if (cb(arr[i])) {   //这里运用回调函数动态的给函数传递了值

newArr.push(arr[i])

}

}
return newArr
}
result = filter(personArr, a => a.age >= 18)  //以实参的形式给函数传递了值
```

用法二：
- 将原函数用作另一个函数的返回值，来动态的生成一个新函数。 --在不修改原函数的基础上，为其增加新功能
```js
function someFn() {     //原函数-功能函数

return "hello"

}

function outer(cb){  //封装原函数，原函数作为参数传入封装函数，让其在返回的回调函数里调用，执行

return () => {   //  返回回调函数，用来封装原函数

console.log("记录日志~~~~~")

const result = cb()       //在回调函数里执行原函数，也可以接收原函数的值返回。

return result

}

}

let result = outer(someFn)   //接收封装函数返回的回调函数，并且给回调函数传原函数作为实参。

result()  //调用接收的回调函数，触发，回调函数里面的原函数执行。
```


### 闭包
>函数在作用域，在函数创建时就已经确定的（词法作用域），和调用的位置无关，闭包就是作用域内层的函数调用作用域外层的变量，并且返回给全局作用域，让全局作用域能够使用外层作用域的变量。闭包就是能访问到外部函数作用域中变量的函数。

>当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包。

- 构成闭包的要件：
1. 函数的嵌套
2. 内部函数要引用外部函数中的变量
3. 内部函数要作为返回值返回
```js
function outer(){
let num = 0 // 要藏的东西可以放这里，这能闭包函数访问、操作，然后闭包函数可以把结果返回。
return () => {
num++
console.log(num)    // 返回的函数，每次调用outer都重新生成函数
}
}
const newFn = outer()   //获取返回的函数，相当于操作隐藏的东西
newFn() //这样才会执行返回的函数，而且可以调用多次。
```
- 闭包的生命周期：
1. 闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
2. 在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）

- 注意事项：
1. 闭包主要用来隐藏一些不希望被外部访问的内容
2. 相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能）

### 递归
- 调用自身的函数称为递归函数
- 递归的作用和循环是基本一致
>递归的核心思想就是将一个大的问题拆分为一个一个小的问题，小的问题解决了，大的问题也就解决了

递归两个要件：
1. 基线条件 —— 递归的终止条件
2. 递归条件 —— 如何对问题进行拆分
递归与循环
- 递归的作用和循环是一致的，不同点在于，递归思路的比较清晰简洁，循环的执行性能比较好
- 在开发中，一般的问题都可以通过循环解决，也是尽量去使用循环，少用递归
```js
// 求斐波那契数列中的第n个数(前两个数之和等于第三个数的数列)

function fib(n) {

// 确定基线条件

if (n < 3) {

return 1

}

// 设置递归条件

// 第n个数 = 第n-1个数 + 第n-2个数

return fib(n - 1) + fib(n - 2)

}

let result = fib(10)
```


## 07_面向对象编程(OOP）
>程序世界一切皆对象，对象就是对一个事物的抽象与集合。
  做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作。
  面向对象本质就是，编写代码时所有的操作都是通过对象来进行的。


### 类的创建
- 使用Object构造函数创建对象的问题： 
	1. 创建的对象属于一个类（Object），对象之间没有类的区分  
	2. 只能批量实例化一种类的对象。 

>类是对象的模板，也就是对对象的抽象。或者说是对象的造物主。
>通过一个类，可以批量创建具有同一属性的对象。这样一批对象都是这个类的子集。

>通过同一个类创建的对象，我们称为同类对象
>如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

- 语法：
```js
class 类名 {} // 类名要使用大驼峰命名
//或者
const 类名 = class {}

通过构造函数创建对象

new 类() //new出一个实例对象，这个对象就是这个类的子集。通过构造函数来创建对象。
```

- `instanceof` 关键字
```js
const p1 = new Person()
console.log(p1 instanceof Person)   //可以使用instanceof来检查一个对象是否是由某个类创建， 返回布尔值
```

### 类的属性和方法
- 类是创建对象的模板，首先应该定义不同的类，这样才能实例出来有定义的对象。
- 类的代码块，默认就是严格模式，且只能写属性和方法，因为类是为了创造对象的。

- 类的属性有两种： 1. 实例属性。 2. 静态属性
- 注意， 实例属性最终也会封装进去实例对象当中， 所以只能通过实例访问
```js
class Person{

name = "孙悟空" // Person的实例属性name p1.name

age = 18 // 实例属性只能通过实例访问 p1.age 

static test = "test静态属性" // 使用static声明的属性，是静态属性（类属性） Person.test

static hh = "静态属性" // 静态属性只能通过类去访问 Person.hh
 
}
```

- 类的方法也有两种： 1. 实例的方法   2. 静态方法
- 用函数声明式创建的方法，会存放在类的原型里。
- 用函数表达式创建的方法，会存放在实例对象中， 因为是变量的方式存放。
```js
class Person{

name = "孙悟空"

sayHello(){       //添加方法最好用函数声明的方式   

console.log('大家好，我是' + this.name)

} // 添加方法（实例方法） 实例方法中this就是当前实例。 因为 p1.sayHello() 实例的方法只能实例来调用。

static test(){

console.log("我是静态方法", this)       

} // 静态方法（类方法） 通过类来调用 静态方法中this指向的是当前类 

  //Person.test() 因为静态方法时类来调用。

}
```


### 类的构造函数

>构造函数又叫构造器，是类中的一个特殊的方法constructor。
>构造函数会在我们调用类创建对象时执行，new Object()

- 构造器的作用
- 可以接收实例化对象传进来的参数，并且通过this给实例化对象添加属性并且赋值。
- 不能添加方法，不然就添加到了实例化对象中了，方法应该添加进原型。
```js
class Person{

name,      //构造器外边添加的方法，直接添加进了原型对象中
			//构造器外边的属性，会直接添加进实例中， 
age,
gender

constructor(name, age, gender){      //实例化对象给构造器传参

// 在构造函数中，this表示实例化的对象
// 可以在构造函数中，为实例属性进行赋值

this.name = name  //构造器通过this给实例化对象里添加属性,并赋值

this.age = age

this.gender = gender

}

}
const p1 = new Person("孙悟空", 18, "男")  //调用构造函数 传参给构造函数，返回一个类的实例 

```


### 类的封装性
- 对象作为一个存储不同属性的容器，对象不仅存储属性，还要负责数据的安全。
- 当我们用类实例化对象出来时候，可以封装类里面的属性，让对象不那么容易访问到里面的属性。
- 封装只能在类里面进行，只能封装类里面的属性。

- ==封装的步骤：==

1. 私有化数据（完全私有，没有意义）

	- 属性私有化，在属性前加# 
	- 将需要保护的数据设置为私有，只能在类内部使用，实例访问不到，不能修改，不能查看。
	- 私有属性只能在类里面声明
```js
class Person {
  
#name, // 实例使用#开头就变成了私有属性，私有属性只能在类内部访问，实例访问不到

#age,

#gender
}
```

2. 通过getter和setter方法来操作属性

	- 可以控制属性的读写权限，实例化可以通过调用方法，改变封装的属性。
	- 可以在方法中对属性的值进行验证。
	- 用get， set 关键字定义方法，在实例化对象中获取时，还是以属性的方式获取而不是以方法的方式。

```js
class Person {

#name,

#age,

#gender

constructor(name, age, gender) {   //实例化传值给类里面的私有属性

this.#name = name  //内部可以修改私有属性的值

this.#age = age

this.#gender = gender

}


// getter方法，用来读取属性

get getAge(){     //用get关键字定义一个方法，

return this.#age    //一定要返回给这个方法一个值

}
  

// setter方法，用来设置属性

set setAge(age){  //set定义的方法，一定要传入一个值

if(age >= 0){

this.#age = age

}

}
}

const p1 = new Person("孙悟空", 18, "男")   //传给类里面的属性
console.log(p1.getage)   //实例化对象获取类里面的属性可以用调用属性的方式，而不是调用方法，
```

### 类的多态性
>同一操作作用于不同的对象上，可以产生不同的解释和不同的执行结果。

- 在JS中因为不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递，
- 要调用某个函数，无需指定的类型，只要对象满足某些条件即可
- 多态为我们提供了灵活性

### 类的继承性
- 继承发生时，被继承的类称为 父类（超类），继承的类称为 子类
- 当子类要用父类的属性方法时，可以通过extends关键词来完成继承。
- 当子类继承父类时，1， 父类变成了子类的原型对象，父类的原型对象变成了子类原型的原型。 2. 当new发生时， 也会触发构造函数， 返回新对象， 从而实现， 属性和方法的继承。
- 通过继承可以减少重复的代码，并且可以==在不修改一个类的前提对其进行扩展==
- OCP 开闭原则 ——程序应该对修改关闭，对扩展开放

1. 直接完整继承父类的属性和方法
```js
class Animal{

constructor(name){

this.name = name

}

sayHello(){

console.log("动物在叫~")

}

}

class Dog extends Animal{ 

//直接继承了父类的构造函数，在{}里可以添加子类的属性和方法作为对父类的扩展。
}

const dog = new Dog("旺财")

dog.sayHello()   //继承了animal类的原型里面的方法
  
```
2. 在子类中，可以通过创建同名方法或者属性来重写父类的方法
```js
class Cat extends Animal{

  
sayHello(){
  
console.log("喵喵喵")   //在子类里面属性和方法，扩展父类。（其实就是原型链原理， 先找近的）

}

}
```
3. 重写构造函数
- 重写构造函数，子类就不能再继承父类的构造函数，必须要用super() 重新调用父类的构造函数。
```js
class Cat extends Animal{
  
// 重写构造函数后，实例化对象会优先使用子类的构造函数，所以实例传参会传给此构造函数

constructor(name, age){


super(name) // 第一行必须是super()，相当于调用父类的构造函数，这样才能继承父类
				// 因为实参传给了子类的构造函数，所以这里要再传给父类，这样父类才能用实例传的参数。

this.age = age     //这里其实是在子类的构造函数里，所以是给实例化对象添加属性

}

sayHello(){

super.sayHello() // 在方法中可以使用super来引用父类的方法

console.log("喵喵喵")

}

}
```


### 对象的结构
>当对象通过构造函数，new出来之后，就天生具有统一的结构。1. 对象自身  2. 对象的原型对象

1. 在对象自身中，存放着对象的属性和方法。
2. 在对象的__proto__属性，存放着该对象的原型对象，其中也存放着该对象的方法。

>当我们访问对象中的方法时，会优先访问对象自身的方法，对象自身不包含该方法时，才会去原型对象中寻找。

==怎么添加属性和方法==
1. 对象自身
	- 直接通过对象所添加的属性，位于对象自身中
	- 在类中通过 x = y 的形式添加的属性，位于对象自身中

2. 原型对象（prototype）
	-  在==类==中通过xxx(){}方式（函数声明）添加的方法，位于原型中
	-  主动向原型中添加的属性或方法

### 对象的原型
>==对象的原型就是创建它的类。==而原型对象就是由： 类的构造器，共有的方法， __ proto __属性组成。

>对象都可以当原型，是一种关系。只是把这种关系以对象的形式出现——原型对象

- 访问原型对象
	1. 实例.__ proto __
	2. Object.getPrototypeOf(对象)
	3. 类.prototype (类的原型对象)

- 原型对象的结构 
	- 各个实例共用的数据（方法）
	-  constructor （原型对象的核心-构造函数）（实例化对象的构造函数）
	- __ proto __ 属性 （原型对象中的这个属性里，放着原型对象的原型对象）
		- constructor（原型的构造函数）
		- 对象的数据（共用方法）
		- __ proto __ 属性 （原型的原型的原型）

- 原型链
	>同类型对象的原型链都是是一样的，因为他们的原型都是一个，他们都有共同的父类。

	- Object实例化对象的原型链：obj对象 --> Object(构造函数) 的原型对象 --> null
	- 实例化对象的原型链：P实例对象 --> P类（构造函数）的原型对象 --> Object(构造函数) 的原型对象-->  null
	- 继承的原型链： TomCat（实例化对象） --> Animal（父类/继承类）的构造函数 --> Animal（父类/继承类）的构造函数的原型对象  -->  Object(构造函数) 的原型对象） --> null


- 原型链的规则
	1. 读取对象属性时，会优先对象自身属性，
	2. 如果对象中有，则使用，没有则去对象的原型中寻找
	3. 如果原型中有，则使用，没有则去原型的原型中寻找
	4. 直到找到Object对象的原型（Object的原型没有原型（为null））如果依然没有找到，则返回undefined

- 原型的作用
	- 原型就相当于是一个公共的区域，可以被所有该类实例访问。可以将该类实例中，所有的公共属性（方法）统一存储到原型中
	- 而JS中继承就是通过原型来实现的，继承时，子类的原型就是父类，而父类的原型，就变成了子类原型的原型

### 原型的修改
>大部分情况下，我们是不需要修改原型对象

修改原型的方法：

1.  通过类的实例去修改原型
```js
// 通过对象修改原型，向原型中添加方法，修改后所有同类实例都能访问该方法 不要这么做
 p.__proto__.run = () => {

 console.log('我在跑~')

 }
p.__proto__ = new Dog() // 直接为对象赋值了一个新的原型 相当于换了一个原型。
```
坏处：
- 通过一个对象影响所有同类对象，影响太大
- 修改原型先得创建实例，麻烦

2. 通过类的prototype属性，来访问实例的原型对象（就是由类自身的构造函数生成的原型对象）
```js
console.log(Person.prototype) // 访问Person实例的原型对象，其实还是Person
```
好处：
- 一修改就是修改所有实例的原型
-  无需创建实例即可完成对类的修改


原则：
1. 原型尽量不要手动改
2. 要改也不要通过实例对象去改
3. 通过 类.prototype 属性去修改
4. 最好不要直接给prototype去赋值

### 对象的检查
  
1. `instanceof`
	- 用来检查一个对象是否是一个类的实例
	- instanceof检查的是对象的原型链上是否有该类实例，只要原型链上有该类实例，就会返回true
```js
// dog -> Animal的实例 -> Object实例 -> Object原型
console.log(dog instanceof Dog) // true

console.log(dog instanceof Animal) // true

console.log(dog instanceof Object) // true
```

2. in 运算符
- 用来检查一个对象中的属性是否存在
- 只要属性在对象自身或者在原型中，都会返回true
```js
console.log("sayHello" in p)
```

3. hasOwnProperty
- 用来检查一个对象的自身是否含有某个属性(不包括原型)（实例的方法）
- 不推荐使用，因为这个是实例的方法，存放在对象的原型中，当对象没有原型时，就不能用。
```js
//对象.hasOwnProperty(属性名)
console.log(p.hasOwnProperty("sayHello"))
```

4. hasOwn
- 用来检查一个对象的自身是否含有某个属性（静态方法）
```js
console.log(Object.hasOwn(p, "sayHello")) 
```


### 旧类
>早期JS中，直接通过函数来定义类， 但是等价于class定义的类
- 一个函数如果直接调用 xxx() 那么这个函数就是一个普通函数
- 一个函数如果通过new调用 new xxx() 那么这个函数就是一个构造函数

```js
var Person = (function () {       //封装一个立即执行函数，让它立即返回一个Person构造函数，然后就等待被调用即可。如果不添加立即执行函数，变量就接收不到其中的返回值，而是接收的是整个函数。

function Person(name, age) {

// 在构造函数中，this表示新建的对象

//等价于构造器了，接收外界的传参，然后给实例赋值。

//但是这里不能写方法，因为这里相当于构造器，会直接写入实例对象中，方法应该写在原型里，
this.name = name     

this.age = age
  
}

// 向原型中添加属性（方法）

Person.prototype.sayHello = function () {

console.log(this.name)

}
  

// 静态属性

Person.staticProperty = "xxx"

// 静态方法

Person.staticMethod = function () {
  
return Person      //返回整个构造函数，这样就可以直接创建实例了。

})()


const p = new Person("孙悟空", 18)


// 继承Animal

Cat.prototype = new Animal()   //继承本质上就是原型的继承，直接添加原型就行了，

  

return Cat

})()

  

var cat = new Cat()
```



### new的原理
使用new调用函数时，将会发生这些事：[网站地址](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new)
>旧类： 把调用的函数变为构造函数使用； class类： 本身自带构造函数

==一切在构造函数中进行，相当于构造函数的执行==
1. 创建一个普通的JS对象（Object对象 {}）, 为了方便，称其为新对象
- 在构造器中进行

2. 将构造函数的prototype属性设置为新对象的原型
- 就是把类的原型变成了新对象的原型，从此新对象的原型对象就是类的原型对象

3. 使用实参来执行构造函数，并且将新对象设置为函数中的this
- 把新对象赋值给了this

4. 如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回（千万不要这么做）
- 相当于构造函数返回出了一个值，被new 接收

5. 如果构造函数的返回值是一个原始值或者没有指定返回值，则新的对象将会作为返回值返回
- 这时，构造函数创建的新对象就会被返回出来，被一个变量接收，这就是实例化的过程。


## 08_数组
### 数组的简介
- 数组也是一种复合数据类型，在数组可以存储多个不同类型的数据，数组本质也是对象
- 数组中存储的是有序的数据，数组中的每个数据都有一个唯一的索引
- 数组中存储的数据叫做元素，可以通过索引来操作获取元素。 索引（index）是一组大于0的整数

- 创建数组
1. 通过Array()来创建数组  
```js
const arr = new Array()
```
2. 也可以通过[]来创建数组 
```js
const arr2 = [1, 2, 3, 4, 5] // 数组字面量
```

- 向数组中添加元素 
```js
//数组[索引] = 元素
arr[0] = 10
arr[1] = 22
```

- 读取数组中的元素
```js
 //数组[索引]
console.log(arr[0]) 
console.log(arr[1])  //如果读取了一个不存在的元素，返回undefined
```

- length——用来获取数组的长度，从1开始计算，所以比索引值多1位。
- length向数组最后添加元素
```js
//数组[数组.length] = 元素
const arr2 = [1, 2, 3, 4, 5] // 数组字面量
arr[arr.length] = 33  //给索引6添加元素 ， 因为length获得的值比索引 + 1。
```

- length可以修改数组的长度
```js
const arr2 = [1, 2, 3, 4, 5] // 数组字面量
arr.length = 10 //数组的长度就会变成10， 但是不足的元素为undefined，如果元素多余就会直接删除。 
```

### 数组的解构赋值
>解构赋值就是解构数组里面的元素，然后依次赋值给一个新的变量。

- 语法： [变量名1， 变量名2] = [元素1， 元素2]
- 解构数组，数组元素赋值给变量
```js
let [d, e, f, g] = ["唐僧", "白骨精", "蜘蛛精", "玉兔精"] // 声明同时解构
//这样右边的数组里面的元素就赋值给了左边的变量（看起来是数组其实还是变量）
let d, e, f
;[d, e, f] = [1, 2, 3] // 先声明，后赋值，防止js误解析【】，可以添加分号。

;[d, e, f, g = 10] = [1, 2, 3]//当有多余的变量接收时，会默认赋值undefined，可以给变量默认赋值。

;[d, e, f = 77, g = g] = [1, 2, 3] //当有多余的变量，同时又不想被赋值undefined，可以给变量赋值自身，变量就会用自身原来的值。不会被undefined覆盖

let [n1, n2, ...n3] = [4, 5, 6, 7] // 解构数组时，可以使用...来设置获取多余的元素
```

- 通过解构数组交换两个变量的值
```js
let a1 = 10

let a2 = 20

;[a1, a2] = [a2, a1] // [20, 10]  把变量变成数组的形式，然后再结构赋值

const arr2 = ["孙悟空", "猪八戒"]

;[arr2[0], arr2[1]] = [arr2[1], arr2[0]]
```

>数组中可以存储任意类型的数据，也可以存数组,如果一个数组中的元素还是数组，则这个数组我们就称为是二维数组
- 二维数组的解构
```js
	const arr3 = [["孙悟空", 18, "男"], ["猪八戒" ,28, "男"]]
	let [[name, age, gender], obj] = arr3 //解构二维数组
```

### 数组的方法
>数组本质也是对象，所以数组是用数组的构造函数实例化出来的，所以数组的方法也分为： 实例的方法，和静态的方法。[参考文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
1.  Array.isArray() -静态方法
- 用来检查一个对象是否是数组 

2. at() -实例方法
- 可以根据索引获取数组中的指定元素
- 参数： 接收索引，可以是负索引，负索引代表倒着排序

3. concat() -实例方法
- 用来连接两个或多个数组 （不影响原数组）
- 参数： 接收数组，可以多个
```js
const arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]
const arr2 = ["白骨精", "蜘蛛精", "玉兔精"]

let result = arr.concat(arr2, ["牛魔王","铁扇公主"]) //链接了多个数组，先后排列合并为新数组
```

4. indexOf() -实例方法
- 获取元素在数组中第一次出现的索引，正序查找
- 参数：1. 要查询的元素； 2. 查询的起始位置
- 找到了则返回元素的索引，没有找到返回-1

5. lastIndexOf() -实例方法
- 获取元素在数组中最后一次出现的位置，倒序查找
- 参数：1. 要查询的元素； 2. 查询的起始位置
- 找到了则返回元素的索引，没有找到返回-1

6. join() -实例方法
- 将一个数组中的元素连接为一个字符串  （不影响原数组）
- 参数：指定一个字符串作为连接符
```js
result = arr.join()  //默认逗号是连接符

result = arr.join("@-@")  //指定连接符

result = arr.join("")  //空串为连接符，不会有任何连接符
```

7. slice()
- 用来截取数组（不影响原数组）
- 参数：1. 截取的起始位置（包括该位置） 2. 截取的结束位置（不包括该位置）
	- 第二个参数可以省略不写，那么就会截取到最后
	- 索引可以是负值， 负值表示倒序
	- 如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）
```js
arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]

result = arr.slice(0, 2)  //截取 孙——猪
result = arr.slice(1, 3) //猪- 沙
result = arr.slice(1, -1)  //猪-沙
```

8. push() -（影响原数组）
- 向数组的末尾添加一个或多个元素，并返回新的长度
```js
let result = arr.push("唐僧", "白骨精")
```

9. pop() -（影响原数组）
- 删除并返回数组的最后一个元素
```js
result = arr.pop() //只删除一个，并返回
```

10. unshift()  -（影响原数组）
- 向数组的开头添加一个或多个元素，并返回新的长度
```js
let result = arr.unshift("牛魔王")
```

11. shift()  -（影响原数组）
- 删除并返回数组的第一个元素
```js
arr.shift() //只删除一个，并返回
```

12. splice()  -（影响原数组）
- 可以删除、插入、替换数组中的元素
- 参数：1. 删除的起始位置   2. 删除的数量   3. 要插入的元素
- 返回值：返回被删除的元素
```js
arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]

 result = arr.splice(1, 3)   //删除数组元素

 result = arr.splice(1, 1, "牛魔王", "铁扇公主", "红孩儿") //删除猪八戒，并顶替它的位置，插入三个元素

result = arr.splice(1, 0, "牛魔王", "铁扇公主", "红孩儿")  //在猪八戒前面 插入三个元素
```

13. reverse() -（影响原数组）
- 反转数组
```js
arr = ["a", "b", "c", "d"]
arr.reverse()
```

14. filter() -（不会对改变原数组）
- 将数组中符合条件的元素保存到一个新数组中返回
- 需要一个回调函数作为参数，和forEach方法一样，有几个元素执行几次回调函数。并根据回调函数的返回值来决定是否将元素添加到新数组中。
- 非破坏性方法，不会影响原数组
```js
arr = [1, 2, 3, 4, 5, 6, 7, 8]
// 获取数组中的所有偶数
let result = arr.filter((ele, index, arr) => ele > 5)  //回调函数里有当前元素，索引值，和当前数组作为参数，当回调函数判断返回值为true时，会把当前判定的当前元素值，传给filter返回的数组里。
```

15. map -（不会对改变原数组）
- 根据当前数组生成一个新数组，可以批量同步操作数组。
- 需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素
- 非破坏性方法不会影响原数组
```js
arr = ["孙悟空", "猪八戒", "沙和尚"]
result = arr.map((ele) => "<li>" + ele + "</li>") //回调函数的返回值存到了新数组中。
```

16. reduce()
- 可以用来将一个数组中的所有元素整合为一个值
- 合并执行逻辑是先整合前两个元素，然后不断往后整合。
- 参数：
1. 回调函数，通过回调函数来指定合并的规则
2. 可选参数，初始值（相当于在数组最前面添加一个新元素，然后参与合并逻辑）
```js
arr = [1, 2, 3, 4, 5, 6, 7, 8]

result = arr.reduce((a, b) => {  //第一个参数回调函数， 里面的两个参数就是要合并的前两个元素，函数里面是合并的规则。

/*

1, 2

3, 3

6, 4

10, 5

*/

// console.log(a, b)

return a * b   //回调函数返回什么，这两个参数合并的结果就是什么，然后在和第三个元素一起合并，不断循环。

}， 10)  //第二个参数为初始值，相当于最开始的元素，然后和数组第一个元素一起合并。

// result = arr.reduce((a, b) => a + b, 10)
```

17. Array.from(links)  
	- 可以把一个类数组对象，转换为一个真正的数组
	- [ ...links ] 扩展运算符也能把类数组转换为真正的数组
18. Array.includes(元素)
	- 判断某一个元素是否在Array数组内， 返回布尔值

### 数组的遍历
1. 用for循环语句
```js

const personArr = [

new Person("孙悟空", 18),

new Person("沙和尚", 38),

new Person("红孩儿", 8),

]

for(let i=0; i<personArr.length; i++){

if(personArr[i].age < 18){

console.log(personArr[i])

}

}
```

2. for-of语句遍历可迭代对象

语法：
- for(变量 of 可迭代的对象){ }

执行流程：
- for-of的循环体会执行多次，数组中有几个元素就会依次执行几次
- 每次执行时都会将一个元素赋值给变量
```js
const arr = ["孙悟空" , "猪八戒", "沙和尚", "唐僧"]

for(let value of arr){     //每次执行把一个元素给value

console.log(value)

}
```

3. forEach()方法遍历

- 它需要一个回调函数作为参数，这个回调函数会被调用多次
- 数组中有几个元素，回调函数就会调用几次，每次调用，都会将数组中的数据作为参数传递
- 回调函数中有三个参数：
	1. element 当前的元素
	2. index 当前元素的索引
	3. array 被遍历的数组
```js
arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]

arr.forEach((element, index, array) => {  //回调函数会调用四次，每次都会传入参数
 console.log(array)

 })

```
### 数组的去重

方法一：
```js
const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7]
  
// 编写代码去除数组中重复的元素
  
// 分别获取数组中的元素

for (let i = 0; i < arr.length; i++) {

// 获取当前值后边的所有值

for (let j = i + 1; j < arr.length; j++) {

// 判断两个数是否相等

if (arr[i] === arr[j]) {

// 出现了重复元素，删除后边的元素

arr.splice(j, 1)


/*

当arr[i] 和 arr[j]相同时，它会自动的删除j位置的元素，然后j+1位置的元素，会变成j位置的元素

而j位置已经比较过了，不会重复比较，所以会出现漏比较的情况

解决办法，当删除一个元素后，需要将该位置的元素在比较一遍

*/

j--

}

}

}
```
 
方法二：
```js
const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7]

// 获取数组中的元素

 for(let i=0; i<arr.length; i++){

 const index = arr.indexOf(arr[i], i+1)

 if(index !== -1){

// // 出现重复内容

 arr.splice(index, 1)

 i--

 }

 }

console.log(arr)
```

方法三： 
```js
const newArr = []

for(let ele of arr){

if(newArr.indexOf(ele) === -1){

newArr.push(ele)

}
}
console.log(newArr)
```

### 数组的排序
1. 冒泡排序
- 比较相邻的两个元素，然后根据大小来决定是否交换它们的位置
```js
const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]

 for (let j = 0; j < arr.length - 1; j++) {

 for (let i = 0; i < arr.length - 1 - j; i++) {

 if (arr[i] > arr[i + 1]) {

 let temp = arr[i]

 arr[i] = arr[i + 1]

 arr[i + 1] = temp

 }

 }
```

2. 选择排序
- 取出一个元素，然后将其他元素和该元素进行比较，如果其他元素比该元素小则交换两个元素的位置
```js
const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]

for(let i=0; i<arr.length; i++){

for(let j=i+1; j<arr.length; j++){

if(arr[i] > arr[j]){

// 交换两个元素的位置

let temp = arr[i]

arr[i] = arr[j]

arr[j] = temp

}
}
}
```

3. sort()方法排序
- sort用来对数组进行排序（会对改变原数组）
- sort默认会将数组升序排列（字母排序a,b,c...数字排序1，2，3）

==注意：sort默认会按照Unicode编码进行排序，当数字使用它排序时， 只能排序10以内的=
- 当使用数字排序时，可以传入参数。
- 参数：
- 可以传递一个回调函数作为参数，通过回调函数来指定排序规则
(a, b) => a - b 升序排列
(a, b) => b - a 降序排列
```js
arr.sort((a, b) => a - b)
arr.sort((a, b) => b - a)
```

### 浅拷贝和深拷贝
- 什么是复制（拷贝）[[VUE3#^01 | 对象的内存]]
>拷贝必须要产生新的对象，对象的赋值不是拷贝，因为两个变量还是指向同一个对象的地址。拷贝变量必须要指向不同的地址。
>拷贝又分 ==深拷贝和浅拷贝==

![[Pasted image 20220926232330.png]]

- 浅拷贝（shallow copy）
- 两个变量如果还有共同指向的地址（原始值除外），那就是浅拷贝。
- 浅拷贝只拷贝了第一层对象，对象的属性还没有拷贝，如果对象中还有对象，那么还是有共同指向的地址。
- 浅拷贝顾名思义，只改变了变量的地址指向（因为只复制了一层对象）
- 如果对象中的属性值是原始值，那么拷贝的深浅是不重要，因为原始值是唯一的。
- 浅拷贝的方法：
```js
//数组的浅拷贝
//  1. 数组的slice方法可以进行浅拷贝
const arr = ["孙悟空", "猪八戒", "沙和尚"]
const arr2 = arr.slice()  

//  2. ... (展开运算符)可以把数组里面的元素展开卸载到另一个数组的最后，实现浅拷贝。或者作为参数卸载到实参里。
const arr3 = [...arr]
result = sum(...arr)

//对象的浅拷贝
//  1.  Object.assign(目标对象, 被复制的对象)
const obj = { name: "孙悟空", age: 18 }
const obj2 = { address: "花果山", age: 28 }
Object.assign(obj2, obj) 或者  const obj2 = Object.assign({}, obj)

//  2.   ... (展开运算符)可以把对象中的属性和值，卸载到另一个对象的最后，如果属性名相同，会实现覆盖。
const obj3 = { address: "高老庄", ...obj, age: 48 }
```

![[Pasted image 20220926235207.png]]

- 深拷贝（deep copy）
- 两个变量如果没有共同指向的地址（原始值除外），那就是深拷贝。
- 深拷贝指不仅复制对象本身，还复制对象中的属性和元素，所以对象的对象的地址指向也改变了。那么两个变量就不会指向共同的地址了。
- 因为性能问题，通常情况不太使用深拷贝

- 深拷贝方法：
- const arr3 = structuredClone(arr) ——专门用来深拷贝的方法
- 用JSON来实现浅拷贝
```js
const str = JSON.stringify(obj)

const obj4 = JSON.parse(str)

const obj5 = JSON.parse(JSON.stringify(obj))
```
![[Pasted image 20220927000921.png]]

==总结==
>之所以区分深浅拷贝就是因为，浅拷贝的对象依然可以修改另一个对象的值，因为浅拷贝只拷贝了一层对象，如果浅拷贝对象的属性还是对象的话，他们就还是共同指向那个对象的地址，也就可以互相修改值。而深拷贝就不会，因为深拷贝同时拷贝了对象的所有属性，他们不在指向共同的地址，也就不会共用一个对象。

## 09_内建对象
>内建对象是ES标准所定义的对象，Object Function String Number JSON Map ....

### Map
- Map用来存储键值对结构的数据（key-value）。
- Object中存储的数据就可以认为是一种键值对结构。
- Map和Object的主要区别：
	- Object中的属性名只能是字符串或符号，如果传递了一个其他类型的属性名，JS解释器会自动将其转换为字符串。
	- Map中任何类型的值都可以称为数据的key

- 创建：

new Map()

- 属性和方法：

map.size 获取map中键值对的数量

map.set(key, value) 向map中添加键值对

map.get(key) 根据key获取值

map.delete(key) 删除指定数据

map.has(key) 检查map中是否包含指定键

map.clear() 删除全部的键值对

map.keys() - 获取map的所有的key-数组的形式

map.values() - 获取map的所有的value - 数组的形式

map.entries() - 获取map的所有的键值对 - 数组的形式

- map转换为数组（二维数组）
```js
const arr = Array.from(map) // [["name","孙悟空"],["age",18]]  转换为一个二维数组
 或者
const arr = [...map]  //用展开运算符 也能转换为数组
```
- 二维数组转换为map
```js
const map2 = new Map([

["name", "猪八戒"],
["age", 18],
[{}, () => {}],

])
```
- 遍历map
```js

for (const entry of map) {  //直接遍历map里面的键值对，["name","孙悟空"] 相当于map数组的遍历？
 
 const [key, value] = entry    //这里解构了entry数组， 也可以循环的时候直接结构

 console.log(key, value)   

 }


 map.forEach((key, value，map)=>{ 

console.log(key, value，map)

 })
```


### Set
- Set用来创建一个集合，它的功能和数组类似，不同点在于Set中不能存储重复的数据。
- Set本质上就是一个map只是键和值一样，所以不能重复。因为键不能重复。

- 创建
- new Set()
- new Set([...])    - 添加数组就可以转换为Set

- 方法
size 获取数量
add() 添加元素
has() 检查元素
delete() 删除元素

- Set转数组
```js
const arr = [...set]  //扩展运算符转数组
```

- 遍历Set
```js
 for(const item of set){
 console.log(item)
 }
```

### Math
>Math一个工具类，不能new一个对象，Math中为我们提供了数学运算相关的一些常量和方法

- 常量：

Math.PI 圆周率

- 方法：

Math.abs() 求一个数的绝对值

Math.min() 求多个值中的最小值

Math.max() 求多个值中的最大值

Math.pow() 求x的y次幂 ，小数次幂等同于平方根

Math.sqrt() 求一个数的平方根

Math.floor() 向下取整

Math.ceil() 向上取整

Math.round() 四舍五入取整

Math.trunc() 直接去除小数位

Math.random() 生成一个0-1之间的随机数
```js
let result = Math.abs(10)

result = Math.abs(-10)

result = Math.min(10, 20, 30, 44, 55, -1)

result = Math.max(10, 20, 30, 44, 55, -1)

result = Math.pow(4, 2) // 4 ** 2

result = Math.sqrt(4) // 4 ** .5

result = Math.floor(1.2)

result = Math.ceil(1.2)

result = Math.round(1.4)

result = Math.trunc(1.5)
```

- 生成随机数
Math.random() --> 0 - 1

生成 0-x之间的随机数：(包括0，x)

Math.round(Math.random() * x)
Math.floor(Math.random() * (x + 1))
  
生成 x-y 之间的随机数： (包括x，y)

Math.round(Math.random() * (y-x) + x)

### Date
>在JS中所有的和时间相关的数据都由Date对象来表示

- 创建时间对象
```js
//创建当前的时间对象
let d = new Date() // 直接通过new Date()创建时间对象时，它创建的是当前的时间的对象


//创建指定的时间对象

// 字符串的格式：月/日/年 时:分:秒 或者 年-月-日T时:分:秒
d = new Date("2019-12-23T23:34:35")  // 可以在Date()的构造函数中，传递一个表示时间的字符串

//new Date(年份, 月, 日, 时, 分, 秒, 毫秒) 推荐这种格式
d = new Date(2016, 0, 1, 13, 45, 33)

//传入时间戳，也可以返回指定的时间对象，但是返回的是东八区的时间对象。
d = new Date(2016)

```

- 时间对象的方法：

	getFullYear() 获取4位年份

	getMonth() 返当前日期的月份（0-11）（因为得到的是月份索引）

	getDate() 返回当前是几日

	getDay() 返回当前日期是周几（0-6） 0表示周日

>时间戳：自1970年1月1日0时0分0秒格林威治时间到当前格林威治时间所经历的毫秒数，计算机底层存储时间时，使用都是时间戳。
>时间戳是绝对时间，时间对象是相对于当地的时间。比如1970年1月1日0时0分0秒是格林威治的时间对象，1970年1月1日8时0分0秒是东八区的时间对象。两者时间戳都是0.

getTime() 返回当前日期对象的时间戳 ， 是Date实例的方法。

Date.now() 获取当前的时间戳 ，直接获取不用获取实例，是Date的方法，不是实例的方法。

- 时间对象转换本地字符串

```js
let result = d.toLocaleDateString() // 将时间对象转换为本地日期字符串, 只转换日期，没有时间

result = d.toLocaleTimeString() // 将时间对象转换为本地时间字符串， 只转换时间，没有时间

result = d.toLocaleString()  //可以将一个时间对象转换为本地时间加日期的格式的字符串
```
- toLocaleString()
	- 可以将一个日期转换为本地时间格式的字符串

- 参数：
1. 描述语言和国家信息的字符串
	- zh-CN 中文中国
	- zh-HK 中文香港
	- en-US 英文美国

2. 需要一个对象作为参数，在对象中可以通过对象的属性来对日期的格式进行配置

	- dateStyle / timeStyle 日期 / 时间的风格

		full

		long

		medium

		short

	- hour12 是否采用12小时值

		true

		false

	- weekday 星期的显示方式

		long

		short

		narrow
		
	- year

		numeric

		2-digit

```js
result = d.toLocaleString("zh-CN", {

year: "numeric",

month: "long",

day: "2-digit",

weekday: "short",

})
```


### 包装类
- 包装类是指内置的五个类对象，通过这五个类可以使原始值包装成对象。
- 但是这些类是给程序自己调用的，当原始值调用方法时，会把原始值包装成对象，调用完毕就变回原始值。
- 不要轻易使用他们创建原始值对象。比如：对象比较时会比较内存地址，两个布尔值对象比较必为false，影响判断。

	String --> 字符串包装为String对象

	Number --> 数值包装为Number对象

	Boolean --> 布尔值包装为Boolean对象

	BigInt --> 大整数包装为BigInt对象

	Symbol --> 符号包装为Symbol对象

- 当我们对一个原始值调用方法或属性时，JS解释器会临时将原始值包装为对应的对象实例，然后调用这个对象的属性或方法。调用完之后就会舍弃整个对象。

- 由于原始值会被临时转换为对应的对象，这就意味着对象中的方法都可以直接通过原始值来调用。

#### 字符串的方法
- 字符串其本质就是一个字符数组，但是是一个伪数组，只是底层很像数组的储存方式。
- 因为原始值创建之后永远不会变，所以这些原始值对象的方法，都不是破坏性方法。

属性和方法：

length 获取字符串的长度

	- 字符串[索引] 获取指定位置的字符

str.at() （实验方法）

	- 根据索引获取字符，可以接受负索引

str.charAt()

	- 根据索引获取字符

str.concat()

	- 用来连接两个或多个字符串， 用运算符更方便

str.includes()

	- 用来检查字符串中是否包含某个内容，有返回true，没有返回false。

str.indexOf()

str.lastIndexOf()

	- 查询字符串中是否包含某个内容，返回索引

str.startsWith()

	- 检查一个字符串是否以指定内容开头

str.endsWith()

	- 检查一个字符串是否以指定内容结尾

str.padStart(7， 0)

str.padEnd(7，0)

	- 通过添加指定的内容，使字符串保持某个长度， 第一个参数是保持的长度，第二个参数是添加的内容

str.replace('被替换内容'， 替换内容')

	- 使用一个新字符串替换一个指定内容

str.replaceAll()

	- 使用一个新字符串替换所有指定内容

str.slice(2， 3)

	- 对字符串进行切片， 起始位置，截取位置

str.substring(2， 3)

	- 截取字符串，切片

str.split()

	- 用来将一个字符串拆分为一个数组，传一个字符，根据这个字符拆分数组，此字符本身删除。

str.toLowerCase()

	- 将字符串转换为小写

str.toUpperCase()

	- 将字符串转换为大写
	
str.trim()

	- 去除前后空格

str.trimStart()

	- 去除开始空格

str.trimEnd()

	- 去除结束空格
	
### 正则表达式
>正则表达式用来定义一个规则，通过这个规则计算机可以检查一个字符串是否符合规则，或者将字符串中符合规则的内容提取出来。

[[JS#正则表达式 | 详细请参见正则表达式]]
- 创建正则表达式的对象
```js
// new RegExp() 可以接收两个参数（字符串） 1.正则表达式 2.匹配模式

let reg = new RegExp("a", "i") // 通过构造函数来创建一个正则表达式的对象
  
// 使用字面量来创建正则表达式：/正则/匹配模式
reg = /a/i
```

# 高级JS
## 一、作用域

> 了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。

作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。

### 局部作用域

局部作用域分为函数作用域和块作用域。


### 函数作用域

在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。
  
```html

<script>

// 声明 counter 函数

function counter(x, y) {

// 函数内部声明的变量

let s = x + y;

console.log(s); // 18

}

  

// 设用 counter 函数

counter(10, 8);

  

// 访问变量 s

console.log(s); // 报错

</script>

```

总结：

1. 函数内部声明的变量，在函数外部无法被访问

2. 函数的参数也是函数内部的局部变量

3. 不同函数内部声明的变量无法互相访问

4. 函数执行完毕后，函数内部的变量实际被清空了

### 块作用域

* 用let const声明

* 在 JavaScript 中使用 `{}` 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。

>let声明

```html

<script>

{

// age 只能在该代码块中被访问

let age = 18;

console.log(age); // 正常

}

// 超出了 age 的作用域

console.log(age); // 报错

let flag = true;

if(flag) {

// str 只能在该代码块中被访问

let str = 'hello world!';

console.log(str); // 正常

}

// 超出了 age 的作用域

console.log(str); // 报错

for(let t = 1; t <= 6; t++) {

// t 只能在该代码块中被访问

console.log(t); // 正常

}

// 超出了 t 的作用域

console.log(t); // 报错

</script>

```

>const声明

JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。

  ```html

<script>

// 必须要有值

const version = '1.0.0';

  

// 不能重新赋值

// version = '1.0.1';

  

// 常量值为对象类型

const user = {

name: '小明',

age: 18

}

  

// 不能重新赋值

user = {};

  

// 属性和方法允许被修改

user.name = '小小明';

user.gender = '男';

</script>

```


总结：

1. `let` 声明的变量会产生块作用域，`var` 不会产生块作用域

2. var相当于给window加属性，而let直接产生变量

3. `const` 声明的常量也会产生块作用域

4. 不同代码块之间的变量无法互相访问

5. 推荐使用 `let` 或 `const`

  

注：开发中 `let` 和 `const` 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 `const` 声明成常量。常量一般全大写声明

  

- | 关键字 | 块级作用域 | 变量提升 | 初始值 | 更改值 | 通过window调用 |

| ------ | :--------: | :------: | :----: | :----: | :------------: |

| let | √ | ×√ | - | Yes | No |

| const | √ | ×√ | Yes | No | No |

| var | × | √ | - | Yes | Yes |

  


###  全局作用域
`<script>` 标签和 `.js` 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。
* `<script>` 标签导入的js文件的变量，同样可以在其他 `<script>` 中使用
  

```html

<script>

// 此处是全局

function sayHi() {

// 此处为局部

}

  

// 此处为全局

</script>

```

  

全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示：

  

```html

<script>

// 全局变量 name

let name = '小明';

// 函数作用域中访问全局

function sayHi() {

// 此处为局部

console.log('你好' + name);

}

  

// 全局变量 flag 和 x

let flag = true;

let x = 10;

// 块作用域中访问全局

if(flag) {

let y = 5;

console.log(x + y); // x 是全局的

}

</script>

```

  

总结：

  

1. 为 `window` 对象动态添加的属性默认也是全局的，不推荐！

2. 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！

3. 尽可能少的声明全局变量，防止全局变量被污染

  

JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。

  

### 作用域链

  

在解释什么是作用域链前先来看一段代码：

  

```html

<script>

// 全局作用域

let a = 1;

let b = 2;

// 局部作用域

function f() {

let c;

// 局部作用域

function g() {

let d = 'yo';

}

}

</script>

```

  

函数内部允许创建新的函数，`f` 函数内部创建的新函数 `g`，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。

  
  

作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示：

  

```html

<script>

// 全局作用域

let a = 1;

let b = 2;

  

// 局部作用域

function f() {

let c;

// let a = 10;

console.log(a); // 1 或 10

console.log(d); // 报错

// 局部作用域

function g() {

let d = 'yo';

// let b = 20;

console.log(b); // 2 或 20

}

// 调用 g 函数

g()

}

  

console.log(c); // 报错

console.log(d); // 报错

f();

</script>

```

  

总结：

  

1. 嵌套关系的作用域串联起来形成了作用 域链

2. 相同作用域链中按着从里到外的规则查找变量

3. 子作用域能够访问父作用域，父级作用域无法访问子级作用域（就近原则）

4. 同级别作用域，不能互相访问

  

### 闭包

  

闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数，如下代码所示：

  

```html

<script>

function foo() {

let i = 0;

  

// 函数内部分函数

function bar() {

console.log(++i);

}

  

// 将函数做为返回值

return bar;

}

// fn 即为闭包函数

let fn = foo();

fn(); // 1

</script>

```

  

总结：

  

闭包：一个作用域有权访问另外一个作用域的局部变量（子作用域访问父作用域局部变量）

  

好处：可以把一个变量使用范围延伸

  

1. 闭包本质仍是函数，只不是从函数内部返回的

2. 闭包能够创建外部可访问的隔离作用域，避免全局变量污染

3. 过度使用闭包可能造成内存泄漏

  

注：回调函数也能访问函数内部的局部变量。

```html

<script>

function fn(a) {

let num = 0;

a(num);

}

fu(function (n) {console.log(n);}); // 0

</script>

```

  

### 变量提升

* 代码执行前，先预解析变量

变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问，

  

```html

<script>

// 访问变量 str

console.log(str + 'world!');

  

// 声明变量 str

var str = 'hello ';

</script>

  

let和var都有提升，但是let定义的变量没有赋值之前是不可以使用、var可以使用是undefined

```

  

总结：

  

1. 变量在未声明即被访问时会报语法错误

2. 变量在声明之前即被访问，变量的值为 `undefined`

3. `let` 声明的变量不存在变量提升，推荐使用 `let`【也有人认为具有提升但是不赋值不能使用】

4. 变量提升出现在相同作用域当中

5. 变量声明前，不能使用变量，死区

6. 实际开发中推荐先声明再访问变量

  

注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 `let` 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可[查阅资料](https://segmentfault.com/a/1190000013915935)。

  

## 二、函数

  

> 知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。

  

### 2.1 函数提升

* 任何作用域执行前都要预解析 --把变量，函数提前解析在最前面

* 代码执行前，先预解析函数

* 提前解析带有名字的函数，解析到当前作用域的最前面

  
  

```html

<script>

// 调用函数

foo();

  

// 声明函数

function foo() {

console.log('声明之前即被调用...');

}

// 不存在提升现象

bar();

var bar = function () {

console.log('函数表达式不存在提升现象...');

}

</script>

```

  

总结：

  

1. 函数提升能够使函数的声明调用更灵活

2. 函数表达式不存在提升的现象，但存在变量提升

3. 函数提升出现在相同作用域当中，

### 2.2 参数

  

函数参数的使用细节，能够提升函数应用的灵活度。

  

#### 默认值

  

```html

<script>

// 设置参数默认值

function sayHi(name="小明", age=18) {

document.write(`<p>大家好，我叫${name}，我今年${age}岁了。</p>`);

}

// 调用函数

sayHi();

sayHi('小红');

sayHi('小刚', 21);

</script>

```

  

总结：

  

1. 声明函数时为形参赋值即为参数的默认值

2. 如果参数未自定义默认值时，参数的默认值为 `undefined`

3. 调用函数时没有传入对应实参时，参数的默认值被当做实参传入

  

#### 动态参数

  

* `arguments` 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。

* 参数不固定时使用，可以遍历数组

  

```html

<script>

// 求生函数，计算所有参数的和

function sum() {

// console.log(arguments);

let s = 0;

for(let i = 0; i < arguments.length; i++) {

s += arguments[i];

}

console.log(s);

}

  

// 调用求和函数

sum(5, 10); // 两个参数

sum(1, 2, 4); // 两个参数

</script>

```

  

总结：

  

1. `arguments` 是一个伪数组

2. `arguments` 的作用是动态获取函数的实参

  

#### 剩余参数

* 用于不固定参数

```html

<script>

function config(baseURL, ...other) {

console.log(baseURL);

// other 是真数组，动态获取实参

console.log(other);

}

  

// 调用函数

config('http://baidu.com', 'get', 'json');

</script>

```

  

总结：

  

1. `...` 是语法符号，置于最末函数形参之前，用于获取多余的实参

2. 借助 `...` 获取的剩余实参

3. ...a相当于arguments，可以传入所有实参

4. 剩余参数时真正的数组，只能放最后一个


### 2.3 箭头函数

箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。

  
```html

<script>

// 箭头函数

let foo = (a) => {

console.log('^_^ 长相奇怪的函数...');

}

// 一个形参，省略小括号

let foo = a => {

}

一行代码，省略大括号，并自动返回值

let foo = a => a * a

// 调用函数

foo();

// 更简洁的语法

let form = document.querySelector('form');

form.addEventListener('click', ev => ev.preventDefault());

</script>

```

  
总结：

1. 箭头函数属于表达式函数，因此不存在函数提升

2. 箭头函数只有一个参数时可以省略圆括号 `()`

3. 箭头函数函数体只有一行代码时可以省略花括号 `{}`，并自动做为返回值被返回

4. 箭头函数中没有 `arguments`，只能使用 `...` 动态获取实参

5. 涉及到this的使用，不建议用箭头函数，因为箭头函数的this指向箭头函数作用域的调用者，相当于父级this

  
## 三、解构赋值

> 知道解构的语法及分类，使用解构简洁语法快速为变量赋值。

解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。


#### 3.1 数组解构

数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示：

变量与值结构上一定要一一对应哪怕不需要

```html

<script>

// 普通的数组

let arr = [1, 2, 3];

// 批量声明变量 a b c

// 同时将数组单元值 1 2 3 依次赋值给变量 a b c

let [a, b, c] = arr;

console.log(a); // 1

console.log(b); // 2

console.log(c); // 3

</script>

```

  

总结：

1. 赋值运算符 `=` 左侧的 `[]` 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量

2. 变量的顺序对应数组单元值的位置依次进行赋值操作

3. 变量的数量大于单元值数量时，多余的变量将被赋值为 `undefined`

4. 变量的数量小于单元值数量时，可以通过 `...` 获取剩余单元值，但只能置于最末位

5. 跟传参有点像，当想赋值特定几个变量时，可以用，，，a，b跳过不要的值

6. 允许初始化变量的默认值，且只有单元值为 `undefined` 时默认值才会生效

注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析

  

#### 3.2 对象解构

对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法

就是把对象里面的属性，解构出来，赋值给左边的属性

如下代码所示：


```html

<script>

// 普通对象

let user = {

name: '小明',

age: 18

};

  

// 批量声明变量 name age

// 同时将数组单元值 1 2 3 依次赋值给变量 a b c

// 这里其实简化了应该是{name:name, age:age}  简化为{name, age}

let {name, age} = {

name: '小明',

age: 18

}

console.log(name); // 小明

console.log(age); // 18

</script>

```

  

总结：

  

1. 赋值运算符 `=` 左侧的 `{}` 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量

2. 对象属性的值将被赋值给与属性名相同的变量

3. 当属性名已经被let声明过，可以 let {name:username, 属性2}用冒号更改变量名

4. 对象中找不到与变量名一致的属性时变量值为 `undefined`

5. 允许初始化变量的默认值，属性不存在或单元值为 `undefined` 时默认值才会生效

  

注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析

  
  
  
  

## 四、面向对象之创建

  

> 了解面向对象的基础概念，能够利用构造函数创建对象。

* 类 -把各种具体的东西的抽象出共性，同一性的概念，可以有很多个

* 对象 - 抽象的实例化，属性和方法的集合体。把抽象的共性，变为具体的实例，只有一个

### 1.1创建对象

#### 字面量

* 字面量底层也是构造函数生成对象（数组）

let obj = {

name: abc，

age:19，

};

#### 构造函数

构造函数是专门用于创建对象的函数，本身也是对象，如果一个函数使用 `new` 关键字调用，那么这个函数就是构造函数。

>构造函数如同类的概念，而实例化是对象的概念，可以说所有的对象都是构造函数的实例化

* 内置构造函数object，new object()；--内置的构造函数用来创建对象

* new Date(); 创建日期函数

* new Array(); 创建数组的函数

##### new的运行原理
1. new会创建一个空白对象
2. 当new一个构造函数时，会执行构造函数
```javascript
	function Person(uname, uage, usex) {
	this.name = uname
	this.age = uage
	this.sex = usex 
	}
	let per = new Person('刘德华'， 18， '男')//会执行构造函数传实参给构造函数，然后把执行后的结果返回一个函数给new，在赋值给per，就形成一个新的实例对象。
```
3. 替换构造函数里的this的指向为new出来的空白对象
2. 默认再返回构造函数执行后的对象，返回到new出来的空白对象里
#### 自定义构造函数

* 自定义构造函数可以创建多样的类，写入多样的属性和方法，可以传参。从而创建多样的实例化对象

```html

<script>

// 定义函数

function Foo() {

console.log('通过 new 也能调用函数...');

}

// 调用函数

new Foo;

</script>

```

  

总结：

  

1. 使用 `new` 关键字调用函数的行为被称为实例化

2. 实例化构造函数时没有参数时可以省略 `()`

3. 构造函数的返回值即为新创建的对象

4. 构造函数内部的 `return` 返回的值无效！

  

注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。

  

##### 实例成员

  

* 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员（给实例化对象添加的属性和方法）。

* 构造函数可以new创建多个实例化对象

```html

<script>

// 构造函数

function Person(小名， 大名) {

// 构造函数内部的 this 就是实例对象

  

// 实例对象中动态添加属性

this.name = 小明;

// 实例对象动态添加方法

this.sayHi = function () {

console.log('大家好~');

}

}

  

// 实例化，p1 是实例对象

// p1 实际就是 构造函数内部的 this

let p1 = new Person(张三，张三疯); --传属性

  

console.log(p1);

console.log(p1.name); // 访问实例属性

p1.sayHi(); // 调用实例方法

</script>

```

  

总结：

  

1. 构造函数内部 `this` 实际上就是实例对象，为其动态添加的属性和方法即为实例成员

2. 实例成员用this创建，指向实例对象

3. 为构造函数传入参数，动态创建结构相同但值不同的对象

4. 实例对象.constructor --返回构造函数本身

5. 实例对象 instanceof 构造函数 --返回布尔值，用于检测实例对象对应的构造函数

  

注：构造函数创建的实例对象彼此独立互不影响。

  

##### 静态成员

  

* 在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法。

* 给构造函数本身添加的属性和方法是静态成员

  

```html

<script>

// 构造函数

function Person(name, age) {

// 省略实例成员

}

  

// 静态属性

Person.eyes = 2;

Person.arms = 2;

// 静态方法

Person.walk = function () {

console.log('^_^人都会走路...');

// this 指向 Person

console.log(this.eyes);

}

</script>

```

  

总结：

  

1. 静态成员指的是添加到构造函数本身的属性和方法

2. 一般公共特征的属性或方法静态成员设置为静态成员

3. 静态成员方法中的 `this` 指向构造函数本身

4. 静态成员与实例成员之间互不影响

  



## 五、面向对象之数据类型

一切皆对象

> 体会 JavaScript 一切皆对象的语言特征，掌握各引用类型和包装类型对象属性和方法的使用。

* 字符串、数值、布尔、undefined、null也被称为简单类型或基础类型

* 对象，数组也被称为复杂数据类型即引用类型。

  

### 数据类型的传递

* 简单数据类型数据储存在栈内存中，值的传递也是栈内存数据的复制，所以互相不影响。

* 普通对象数据保存在堆内存之中，栈内存中保存了普通对象在堆内存的地址。

* 普通对象在赋值时只是复制了栈内中的地址，而非堆内存中的数据

* 普通对象赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。


总结：

面试回答堆与栈的区别：

1. 堆和栈是内存中的数据存储空间

2. 简单类型的数据保存在内存的栈空间中

3. 引用类型的数据保存在内存的堆空间中，栈内存中存取的是引用类型的地址（房间号）

### 2.1 引用类型
  
#### Object

`Object` 是内置的构造函数，用于创建普通对象。

```html

<script>

// 通过构造函数创建普通对象

let user = new Object({name: '小明', age: 15});

  

// 这种方式声明的变量称为【字面量】

let student = {name: '杜子腾', age: 21}

// 对象语法简写

let name = '小红';

let people = {

// 相当于 name: name

name,

// 相当于 walk: function () {}

walk () {

console.log('人都要走路...');

}

}

  

console.log(student.constructor);

console.log(user.constructor);

console.log(student instanceof Object);

</script>

```

1. 推荐使用字面量方式声明对象，而不是 `Object` 构造函数

2. `Object.assign` 静态方法创建新的对象

3. `Object.keys` 静态方法获取对象中所有属性（键）

4. `Object.values` 静态方法获取对象中所有属性值

  

#### Array

`Array` 是内置的构造函数，用于创建数组。

任何一个数组都是Array构造函数的实例化对象（Object同理）

  

```html

<script>

// 构造函数创建数组

let arr = new Array(5, 7, 8);

  

// 字面量方式创建数组

let list = ['html', 'css', 'javascript'];

  

console.log(list.constructor);

console.log(list instanceof Array);

</script>

```

总结：

1. 推荐使用字面量方式声明数组，而不是 `Array` 构造函数

2. 实例方法 `forEach` 用于遍历数组，替代 `for` 循环

* arr.forEach( function(item, index, arr){});

3. 实例方法`find` 用于查找首次出现的满足条件的值，并返回值

let re = arr.find( function(item, index, arr){ return item > 5;});

4. 实例方法 `some` ，用于查找首次出现的满足条件的值，并返回true

let re = arr.some( function(item, index, arr){ return （筛选条件）;});

5. 实例方法 `evey` ，用于查找都满足条件的值，并返回true

let re = arr.evey( function(item, index, arr){ return item > 5;});

6. 实例方法 `filter` 用于查找满足条件的值，并返回值，生成新数组

let re = arr.filter( function(item, index, arr){ return item > 5;});

7. 实例方法 `map` 让数组每一个元素都执行回调函数，并返回值，生成新数组

let re = arr.filter( function(item, index, arr){ return item * item;});

8. 实例方法 `join` 数组单元素拼接成了符串

9. 实例方法 `concat` 合并两个数组，生成新数组

10. 实例方法 `sort` 对原数组单元值编码排序 所以！

* 正序排序 arr.sort(function (a, b){return a - b;});

* 倒序排序 arr.sort(function (a, b){return b - a;});

8. 实例方法 `splice` 删除或替换原数组单元

9. 实例方法 `indexOf` 检索数组首次出现的索引没有就返回-1

10. 实例方法 `reverse` 反转数组

11. 静态方法 `from` 伪数组转成数组 （伪数组必须有length属性）

12. 静态方法 `isArray` 判断是不是数组，返回布尔


#### RegExp
  
`RegExp` 内置的构造函数，用于创建正则表达式。

* 正则也是对象，也有方法和属性

当使用构造函数创建正则时有两种写法：

```html

<script>

// 构造函数创建正则

// 使用 '' 定义正则

let reg = new RegExp('\d', 'i');

  

// 字面量方式创建正则

// let reg = /(\d)/i;

  

reg.exec('123');

</script>

```

  
  

```html

<script>

// 使用 // 定义正则

let reg = new RegExp(/\d/);

// 如果使用引号定义正则时，\d、\s、\w

需要多添加一个 \

let reg1 = new RegExp('\\d');

</script>

```

总结：

  

1. 推荐使用字面量定义正则表达式，而不是 `RegExp` 构造函数

2. `RegExp` 静态属性 $1、$2、$3、... 获取正则分组单元

  
  
  
  

### 2.2 包装类型

  

在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例：

```html

<script>

// 字符串类型

let str = 'hello world!';

// 统计字符的长度（字符数量）

console.log(str.length); --可以使用属性，因为包装类型

// 数值类型

let price = 12.345;

// 保留两位小数

price.toFixed(2);

</script>

```

  

之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。

  

#### String

  

`String` 是内置的构造函数，用于创建字符串。

  

```html

<script>

// 使用构造函数创建字符串

let str = new String('hello world!');

  

// 字面量创建字符串

let str2 = '你好，世界！';

  

// 检测是否属于同一个构造函数

console.log(str.constructor === str2.constructor); // true

console.log(str instanceof String); // false

</script>

```

  

总结：

  

1. 推荐使用字面量方式声明字符串，而不是 `String` 构造函数

2. 实例属性 `length` 用来获取字符串的度长

3. 实例方法 `trim` 用来将字符串两端空白去掉

4. 实例方法 `split` 用来将字符串拆分成数组

5. 实例方法 `toUpperCase` 用于将字母转换成大写

6. 实例方法 `toLowerCase` 用于将字母转换成小写

7. 实例方法 `slice` 用于字符串截取

8. 实例方法 `indexOf` 检测是否包含某字符

9. 实例方法 `startsWith` 检测是否以某字符开头

10. 实例方法 `endsWith` 检测是否以某字符结尾

11. 实例方法 `replace` 用于替换字符串，支持正则匹配

12. 实例方法 `padStart` 固定长度字符开始位置打补丁

13. 实例方法 `padEnd` 固定长度字符结束位置打补丁

14. 实例方法 `match` 用于查找字符串，支持正则匹配

  
注：String，也可以当成函数，强制转换值为字符串数据类型。toString()也是使用构造函数转换的
  

#### Number  

`Number` 是内置的构造函数，用于创建数值。
  

```html

<script>

// 使用构造函数创建数值

let x = new Number('10');

let y = new Number(5);

  

// 字面量创建数值

let z = 20;

  

// 检测是否属于同一个构造函数

console.log(x.constructor === z.constructor);

</script>

```

  

总结：

  

1. 推荐使用字面量方式声明数值，而不是 `Number` 构造函数

2. 实例方法 `toFixed` 用于设置保留小数位的长度

  

注：Number 也可以当做普通函数使用，这时它的作用是强制转换成数值数据类型。

  

#### Boolean

  

`Boolean` 是内置的构造函数，用于创建布尔值。

  

```html

<script>

// 使用构造函数创建布尔类型

let locked = new Boolean('10');

  

// 字面量创建布尔类型

let flag = true;

  

// 检测是否属于同一个构造函数

console.log(locked.constructor === flag.constructor);

</script>

```

  

总结：

  

1. 推荐使用字面量方式声明布尔值，而不是 `Boolean` 构造函数

  

注：Boolean 也可以当做普通函数使用，这时它的作用是强制转换成布尔类型数据，由其它数据类型转换成布尔类型的数据被称为真值（truly）或假值（falsly）。

  

### 2.3 写在最后

  

至此对 JavaScript 有了更深的理解，即 JavaScript 中一切皆为对象，还有以前学习的 window、Math 对象，最后补充一点无论是引用类型或是包装包类型都包含两个公共的方法 `toString` 和 `valueOf` undefined null  不能使用此方法

  

```html

<script>

// 对象类型数据

let user = {name: '小明', age: 18}

// 数值类型

let num = 12.345;

// 字符串类型

let str = 'hello world!';

str.valueOf(); // 原始值

user.toString(); // 表示该对象的字符串

</script>

```

  

总计：

  

1. `valueOf` 方法获取原始值，数据内部运算的基础，很少主动调用该方法

2. `toString` 方法以字符串形式表示对象,

  
  
  

## 六、面向对象的特征

  

> 学习 JavaScript 中基于原型的面向对象编程序的`语法实现，理解面向对象编程的特征。

  

面向对象编程是一种程序设计思想，它具有 3 个显著的特征：封装、继承、多态。

  

### 1.1 封装

封装的本质是将具有关联的代码组合在一起，其优势是能够保证代码复用且易于维护，函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，但提供了更高级的封装形式。


#### 命名空间（普通函数）

先来回顾一下以往代码封装的形式：

  
```html

<script>

// 普通对象（命名空间）形式的封装

let beats = {

name: '狼',

setName: function (name) {

this.name = this.name;

},

getName() {

console.log(this.name);

}

}

  

beats.setName('熊');

beats.getName();

</script>

```

  

以往以普通对象（命名空间）形式封装的代码只是单纯把一系列的变量或函数组合到一起，所有的数据变量都被用来共享（使用 this 访问）。

  

#### 构造函数

构造函数封装可以独立各个对象数据

```html

<script>

function Person() {

this.name = '佚名';

// 设置名字

this.setName = function (name) {

this.name = name;

}

// 读取名字

this.getName = () => {

console.log(this.name);

}

}

  

// 实例对像，获得了构造函数中封装的所有逻辑

let p1 = new Person();

p1.setName('小明');

console.log(p1.name);// 小明

  

// 实例对象

let p2 = new Person();

console.log(p2.name); // 佚名

</script>

```

构造函数相当于一个"模子"，能够像字面量那样创建出对象来，所不同的是借助构造函数创建出来的实例对象之间是**彼此不影响**的。
  

总结：

1. 构造函数体现了面向对象的封装特性
2. 构造函数实例创建的对象彼此独立、互不影响
3. 命名空间式的封装无法保证数据的独立性
4. 构造函数式的封装，构造方法时，会产生很多多余的空间。因为每一次构造，都会开辟新的空间
  
  

##### 原型对象

* 实际上每一个构造函数都有一个名为 `prototype` 的属性，译成中文是原型的意思
* `prototype` 是对象数据类型，称为构造函数的原型对象
* 每个原型对象都具有 `constructor` 属性指向该原型对象对应的构造函数本身。

  

来看原型对象具体的作用，如下代码所示：

  

```html

<script>

function Person() {

// 此处未定义任何方法

}

  

// 为构造函数的原型对象添加方法

Person.prototype.sayHi = function () {

console.log('Hi~');

}

// 实例化

let p1 = new Person();

p1.sayHi(); // 输出结果为 Hi~

</script>

```

* 原型对象里面的方法，实例对象也可以调用

  
  

```html

<script>

function Person() {

// 此处定义同名方法 sayHi

this.sayHi = function () {

console.log('嗨!');

}

}

  

// 为构造函数的原型对象添加方法

Person.prototype.sayHi = function () {

console.log('Hi~');

}

  

let p1 = new Person();

p1.sayHi(); // 输出结果为 嗨!

</script>

```

  

* 构造函数 `Person` 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函数中的方法

  
  

```html

<script>

function Person() {

// 此处定义同名方法 sayHi

this.sayHi = function () {

console.log('嗨!' + this.name);

}

}

  

// 为构造函数的原型对象添加方法

Person.prototype.sayHi = function () {

console.log('Hi~' + this.name);

}

// 在构造函数的原型对象上添加属性

Person.prototype.name = '小明';

  

let p1 = new Person();

p1.sayHi(); // 输出结果为 嗨!

let p2 = new Person();

p2.sayHi();

</script>

```

  

总结：

* 实际开发往往会将封装的功能函数添加到原型对象中。因为原型对象里的方法与实例对象共有的

* 调用构造函数的属性或方法时，先在当前实例成员是查找，然后再去原型对象查找，并且原型对象被所有实例共享。

* 每一个构造函数都有原型对象（显式原型）。

* 每一个原型对象都有constructor属性，指向当前构造函数，所以实例对象可以直接调用constructor，返回当前构造函数。（原型对象被所有实例共享）

* 每一个实例对象都有_proto_属性，指向原型对象（隐式原型），也是原型对象里的方法可以共享的原理

* 也就是原型对象指向构造函数，实例对象里的_proto_指向原型对象

  

### 1.2 继承

继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。


继承的原因：


```html

<script>

// 封装中国人的行为特征

function Chinese() {

// 中国人的特征

this.arms = 2;

this.legs = 2;

this.eyes = 2;

  

this.skin = 'yellow';

this.language = '中文';

  

// 中国人的行为

this.walk = function () {}

this.sing = function () {}

this.sleep = function () {}

}

  

// 封装日本人的行为特征

function Japanese() {

// 日本人的特征

this.arms = 2;

this.legs = 2;

this.eyes = 2;

  

this.skin = 'yellow';

this.language = '日文';

  

// 日本人的行为

this.walk = function () {}

this.sing = function () {}

this.sleep = function () {}

}

</script>

```

  

其实我们都知道无论是中国人、日本人还是其它民族，人们的大部分特征是一致的，然而体现在代码中时人的相同的行为特征被重复编写了多次，代码显得十分冗余


##### 原型继承

基于构造函数原型对象实现面向对象的继承特性。


```html

<script>

// 所有人

function Person() {

// 人的特征

this.arms = 2;

this.legs = 2;

this.eyes = 2;

// 人的行为

this.walk = function () {}

this.sing = function () {}

this.sleep = function () {}

}

// 中国人

function Chinese() {

this.skin = 'yellow';

this.language = '中文';

}

// 日本人

function Japanese() {

this.skin = 'yellow';

this.language = '日文';

}

</script>

```

  

* 上述代码可以理解成将 `Chinese` 和 `Japanese` 共有的属性和方法提取出来了

* 原型对象的属性和方法恰好是可以被用来共享的

###### 方法一

* 创建【共有】的行为特征是对象

* 把公共对象写入构造函数的原型对象

* 给原型对象重新赋值构造器，指会构造函数本身

  

```html

<script>

// 人们【共有】的行为特征

let people = {

// 人的特征

arms: 2,

legs: 2,

eyes:2,

// 人的行为

walk: function () {},

sleep: function () {},

sing: function () {}

}

// 中国人

function Chinese() {

this.skin = 'yellow';

this.language = '中文';

}

// 日本人

function Japanese() {

this.skin = 'yellow';

this.language = '日文';

}

// 英国人

function Englist() {

this.skin = 'white';

this.language= '英文';

}

// 中国人

// 把公共对象写入构造函数的原型对象

Chinese.prototype = people;

// 给原型对象重新赋值构造器

Chinese.prototype.constructor = Chinese;

let c1 = new Chinese();

// 日本人

Japanese.prototype = people;

Janpanese.prototype.constructor = Japanese;

// 英国人

English.prototype = people;

English.prototype.constructor = English;

// ...

</script>

```

这种方法创建的继承，会改变构造器的指向，因为对象会被的覆盖，重新添加构造器的时候会被覆盖

###### 方法二

构造函数来实现：

* 把公共特征的对象用构造函数的实例化对象替代

* 这样每次添加对象到原型的时候，都会new出新对象，不会覆盖构造器了

![prototype_7](prototype_7.png)

  

```html

<script>

// 所有人

function Person() {

// 人的特征

this.arms = 2;

this.legs = 2;

this.eyes = 2;

  

// 人的行为

this.walk = function () {}

this.sing = function () {}

this.sleep = function () {}

}

  

// 封装中国人的行为特征

function Chinese() {

// 中国人的特征

this.skin = 'yellow';

this.language = '中文';

}

  

// 封装日本人的行为特征

function Japanese() {

// 日本人的特征

this.skin = 'yellow';

this.language = '日文';

}

  

// human 是构造函数 Person 的实例

let human = new Person();

  

// 中国人

Chinese.prototype = new Person();

Chinese.prototype.constructor = Chinese;

// 日本人

Japanese.prototype = human;

Japanese.prototype.constructor = Japanese;

</script>

```

  
  

##### 原型链

  

基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链，如下图所示：

  

![prototype_7](prototype_7.png)

  

```html

作用：用于查找成员提供机制

  

<script>

// Person 构造函数

function Person() {

this.arms = 2;

this.walk = function () {}

}

// Person 原型对象

Person.prototype.legs = 2;

Person.prototype.eyes = 2;

Person.prototype.sing = function () {}

Person.prototype.sleep = function () {}

// Chinese 构造函数

function Chinese() {

this.skin = 'yellow';

this.language = '中文';

}

// Chinese 原型对象

Chinese.prototype = new Person();

Chinese.prototype.constructor = Chinese;

// 实例化

let c1 = new Chinese();

console.log(c1);

</script>

```

* 只要是对象，就有_proto_属性指向其所在构造函数的原型对象

* 构造函数的实例化对象指向其构造函数的原型对象，此原型对象也有_proto_属性指向Object构造函数的原型对象。Object构造函数的原型对象指向一个null值

* 所有对象来源于Object构造函数，所有对象都可以调用Object原型对象的方法

* 原型对象的属性共享，但是就近原则查找

* 可以给Object，array 构造函数的原型对象添加方法，然后所有的对象，数组都可以使用

* 数组、对象的实例的方法，都在其构造函数的原型对象中，所以数组，对象的实例才可以调用

  

>* 每一个函数都有prototype属性，和_proto_属性因为函数还是对象，是Object的实例化对象。

>* 每一个对象都有_proto_属性，指向构造函数的实例化对象

  
  

### 1.3异常处理

  

> 了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。

  

##### throw

  

异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行。

  

```html

<script>

function counter(x, y) {

  

if(!x || !y) {

// throw '参数不能为空!';

throw new Error('参数不能为空!');

}

  

return x + y;

}

  

counter();

</script>

```

  

总结：

  

1. `throw` 抛出异常信息，程序也会终止执行

2. `throw` 后面跟的是错误提示信息

3. `Error` 对象配合 `throw` 使用，能够设置更详细的错误信息

  

##### try ... catch

  

```html

<script>

function foo() {


try {

// 查找 DOM 节点

var p = docunent.querySelector('p');


} catch(error) {

// try 代码段中执行有错误时，会执行 catch 代码段


// 查看错误信息

console.log(error.message);


// 终止代码继续执行

return;

}


// 改变文本样式

p.style.color = 'red';

}

foo();

</script>

```

  

总结：

  

1. `try...catch` 用于捕获错误信息

2. 将预估可能发生错误的代码写在 `try` 代码段中

3. 如果 `try` 代码段中出现错误后，会执行 `catch` 代码段，并截获到错误信息

  
  
  

## 七、this


> 了解函数中 this 在不同场景下的默认值，知道动态指定函数 this 值的方法。

* 任何一个作用域都有一个this

### 1.1 默认值

  

`this` 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 `this` 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 `this` 默认的取值】情况进行归纳和总结。

> 函数里的this指向调用者

* 普通函数指向window，因为window调用

* 构造函数指向实例化对象

* 对象的方法指向该对象，因为对象调用方法

* 事件处理函数指向事件源

* 定时器指向window，因为window调用

#### 普通函数

  

**普通函数**的调用方式决定了 `this` 的值，即【谁调用 `this` 的值指向谁】

* 因为普通函数谁都可以调用。所以其this是变化的

  

```html

<script>

// 普通函数

function sayHi() {

console.log(this);

}

// 函数表达式

let sayHello = function () {

console.log(this);

}

// 函数的调用方式决定了 this 的值

sayHi(); // window

window.sayHi();

// 普通对象

let user = {

name: '小明',

walk: function () {

console.log(this);

}

};

// 动态为 user 添加方法

user.sayHi = sayHi;

uesr.sayHello = sayHello;

// 函数调用方式，决定了 this 的值

user.sayHi();

user.sayHello();

</script>

```

> 普通函数没有明确调用者时 `this` 值为 `window`

> 严格模式下没有调用者时 `this` 的值为 `undefined`。

  

#### 箭头函数

  

**箭头函数**中的 `this` 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 `this` ！箭头函数中访问的 `this` 不过是箭头函数所在作用域的 `this` 变量。（上级作用域的this）

  

```html

<script>

console.log(this); // 此处为 window

// 箭头函数

let sayHi = function() {

console.log(this); // 该箭头函数中的 this 为函数声明环境中 this 一致

}

  

// 普通对象

let user = {

name: '小明',

// 该箭头函数中的 this 为函数声明环境中 this 一致

walk: () => {

console.log(this);

},

sleep: function () {

let str = 'hello';

console.log(this);

let fn = () => {

console.log(str);

console.log(this); // 该箭头函数中的 this 与 sleep 中的 this 一致

}

// 调用箭头函数

fn();

}

}

  

// 动态添加方法

user.sayHi = sayHi;

// 函数调用

user.sayHi();

user.sleep();

user.walk();

</script>

```

  

在开发中【使用箭头函数前需要考虑函数中 `this` 的值】，**事件回调函数**使用箭头函数时，`this` 为全局的 `window`，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：

  

```html

<script>

// DOM 节点

let btn = document.querySelector('.btn');

  

// 箭头函数 此时 this 指向了 window

btn.addEventListener('click', () => {

console.log(this);

})

  

// 普通函数 此时 this 指向了 DOM 对象

btn.addEventListener('click', function () {

console.log(this);

})

</script>

```

  

同样由于箭头函数 `this` 的原因，**基于原型的面向对象也不推荐采用箭头函数**，如下代码所示：

  

```html

<script>

function Person() {

  

}

  

// 原型对像上添加了箭头函数

Person.prototype.walk = () => {

console.log('人都要走路...');

console.log(this); // widow

}

  

let p1 = new Person();

p1.walk();

</script>

```

  

### 1.2 定义值

指定函数中 `this` 的指向

* 有 3 个方法可以动态指定普通函数中 `this` 的指向：

#### call

  

使用 `call` 方法调用函数，同时指定函数中 `this` 的值，使用方法如下代码所示：

  

```html

<script>

// 普通函数

function sayHi() {

console.log(this);

}

  

let user = {

name: '小明',

age: 18

}

  

let student = {

name: '小红',

age: 16，

}

  

// 调用函数并指定 this 的值

sayHi.call(user); // this 值为 user

sayHi.call(student); // this 值为 student

  

// 求和函数

function counter(x, y) {

return x + y;

}

  

// 调用 counter 函数，并传入参数

let result = counter.call(null, 5, 10); this指向null，并调用函数传参

console.log(result);

</script>

```

  

总结：

  

1. `call` 方法能够在调用函数的同时指定 `this` 的值

2. 使用 `call` 方法调用函数时，第1个参数为 `this` 指定的值

3. `call` 方法的其余参数会依次自动传入函数做为函数的参数

4. 使用call方法自动调用函数，并修改this指向。但是调用完毕，就恢复。一次性的调用

  

#### apply

  

使用 `apply` 方法**调用函数**，同时指定函数中 `this` 的

* 和call方法一样，只是call是普通传参，apply是数组传参

  

```html

<script>

// 普通函数

function sayHi() {

console.log(this);

}

  

let user = {

name: '小明',

age: 18

}

  

let student = {

name: '小红',

age: 16

}

  

// 调用函数并指定 this 的值

sayHi.apply(user); // this 值为 user

sayHi.apply(student); // this 值为 student

  

// 求和函数

function counter(x, y) {

return x + y;

}

  

// 调用 counter 函数，并传入参数

let arr = [5, 10];

let result = counter.apply(null, arr);不改this就指向null，传参只能传数组

console.log(result);

</script>

```

  

总结：

  

1. `apply` 方法能够在调用函数的同时指定 `this` 的值

2. 使用 `apply` 方法调用函数时，第1个参数为 `this` 指定的值

3. `apply` 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数

4. apply也会直接调用函数，所以可以用来当做传参数组的工具

>传参数组的工具也可以用...扩展运算符

* 在数组，字符串，对象中...arr代表，展开数组中的值，就可以传参了

  

#### bind

  

`bind` 方法并**不会调用函数**，而是创建一个指定了 `this` 值的新函数，使用方法如下代码所示：


```html

<script>

// 普通函数

function sayHi() {

console.log(this);

}

  

let user = {

name: '小明',

age: 18

}

  

// 调用 bind 指定 this 的值

let sayHello = sayHi.bind(user);

  

// 调用使用 bind 创建的新函数

sayHello();

</script>

```

  

注：`bind` 方法创建新的函数，与原函数的唯一的变化是改变了 `this` 的值。

  

**改变this三个方法总结：**

  

```

call：fun.call(this，arg1, arg2,......)

apply：fun.apply(this, [arg1, arg2,......])

bind：fun.bind(this, arg1, arg2,......)

  

相同点：

都可以用来改变this指向，第一个参数都是this指向的对象

区别：

call和apply：都会使函数执行，但是参数不同

bind：不会使函数执行，参数同call

```

  
  
  

## 八、class

  

传统面向对象的编程序语言都是【类】的概念，对象都是由类创建出来，然而早期 JavaScript 中是没有类的，面向对象大多都是基于构造函数和原型实现的，但是 ECMAScript 6 规范开始增加了【类】相关的语法，使得 JavaScript 中的面向对象实现方式更加标准。

  

### 2.1 封装

  

class（类）是 ECMAScript 6 中新增的关键字，专门用于创建类的，类可被用于实现逻辑的封装。

  

```html

<script>

// 创建类

class Person {

// 此处编写封装逻辑

}

  

// 实例化

let p1 = new Person();

console.log(p1);

</script>

```

  

#### 实例成员

  

```html

<script>

// 创建类

class Person {

// 实例属性

name = '小明';

// 实例属性二

name ： '小明';

  

// 实例方法

sleep () {

console.log('sleeping...')

}

}

  

// 实例化

let p1 = new Person();

p1.sayHi();

</script>

```

  

总结：

  

- 关键字 `class` 封装了所有的实例属性和方法（类里面只能添加属性和方法也就是成员）

- 类中封装的并不是变量和函数，因此不能使用关键字 `let`、`const` 或 `var`

- 类里面的实例成员，属性直接写，实例方法不加function，并且自动的添加到了其原型对象中

* 并且方法之间不用逗号

* 有一个问题就是从构造函数创建对象到class创建对象，缺少了构造函数的传参，不能更改属性值，后续要解决

#### 静态成员

  

```html

<script>

// 创建类

class Person {

// 静态属性

static version = '1.0.0';

  

// 静态方法

static getVersion = function () {

console.log(this.version);

}

}

// 静态方法二

static getVersion () {

console.log(this.version);

}

}

// 静态方法直接访问

console.log(Person.version);

Person.getVersion();

</script>

```

  

总结：

  

- `static` 关键字用于声明静态属性和方法

- 也是方法不用添加function

- 静态属性和方法直接通过类名进行访问，并且只能类访问

  

#### 构造函数

  

创建类时在类的内部有一个特定的方法 `constructor` ，该方法会在类被实例化时自动被调用，常被用于处理一些初始化的操作。

  

```html

<script>

class Person {

// 实例化时 立即执行

// 构造函数、构造方法、构造器

constructor (name, age) {

this.name = name; --实例化属性

this.age = age;

}

// 实例方法

walk () {

console.log(this.name + '正在走路...');

}

}

// 实例化

let p1 = new Person('小明', 18);

p1.walk();

</script>

```

  

总结：

  

- `constructor` 是类中固定的方法名

- `constructor` 方法在实例化时立即执行

- `constructor` 方法接收实例化时传入的参数

- `constructor` 并非是类中必须要存在的方法

- 类里面共有的属性（构造器里面的）要加this

- 只有需要传参时才需要写，所以 构造器里面写实例化属性，外边写实例化方法

- 实例化方法中的this不一定指向实例化对象

  

### 2.2 继承

  

#### extends

  

`extends` 是 ECMAScript 6 中实现继承的简洁语法，代码如下所示：

  

```html

<script>

class Person {

// 父类的属性

legs = 2;

arms = 2;

eyes = 2;

// 父类的方法

walk () {

console.log('人类都会走路...');

}

// 父类的方法

sleep () {

console.log('人都得要睡觉...');

}

}

  

// Chinese 继承了 Person 的所有特征

class Chinese extends Person {}

  

// 实例化

let c1 = new Chinese();

c1.walk();

</script>

```

* 继承了父类实例化属性和方法

如上代码所示 `extends` 是专门用于实现继承的语法关键字，`Person` 称为父类、`Chinese` 称为子类。

  

#### super

  

在继承的过程中子类中 `constructor` 中必须调 `super` 函数，否则会有语法错误，如下代码所示：

  

```html

<script>

class Person {

// 构造函数

constructor (name, age) {

this.name = name;

this.age = age;

}

// 父类的属性

legs = 2;

arms = 2;

walk () {

console.log('人类都会走路...');

}

}

  

// 子类 English 继承了父类 Person

class English extends Person {

// 子类的构造函数

constructor (name, age) {

super(name, age);

// 子类的属性

this.skin = 'white';

this.language = '英文';

}

walk () {

super.walk();

console.log('人类都不走路...');

}

}

  

// 实例化

let e1 = new English('jack', 18);

console.log(e1.name);

</script>

```

  

子类构造函数中的 `super` 函数的作用是可以将子类实例化时获得的参数传入父类的构造函数之中。

* 当子类没有写构造器传参时，直接继承父类的属性方法，可以直接调用传参就可以

* 但是当子类有自己的构造器是，调用传参就会先传到子类的构造器里

* 当子类有自己的构造器传参时，还想用父类的属性，就要用super，这样调用时就先传给父类的属性，再传给子类的属性

* 方法不需要传参，直接可以调用，当方法一样是，依据就近原则，先用子类的。当想用父类方法时，也需要加super，

  
## 九、拷贝
  
* 拷贝不是直接赋值
* 赋值是直接传递地址


### 1.1 浅拷贝

  

```html

<script>

  

含义：只拷贝最外面层的拷贝方式

let obj = {

uname : '张三丰',

age : 22,

sex : '男',

color : ['red', 'blue', 'yellow', 'pink'],

message : {

index : 1,

score : 99

}

}

  

let newObj = {};

// 遍历

for (let key in obj) {

newobj[key] = obj[key]

}

// Object方法

Object.assign(newObj, obj);

console.log( obj, newObj );

<script>

```

* 浅拷贝用遍历或者方法的方式，一个一个把一个对象里的键和值，在另一个对象中重新创建，重新在堆内存中开辟空间（因为键值对是简单数据类型）

* 但是，当值为复杂数据类型时，创建的值还是地址，这就是浅拷贝

  
  

### 1.2 深拷贝

  

```html

<script>

含义：所有层都拷贝的方式

  

let obj = {

uname : '张三丰',

age : 22,

sex : '男',

color : ['red', 'blue', 'yellow', 'pink'],

message : {

index : 1,

score : 99

}

}

  

let newObj = {};

  

function kaobei (newObj, obj) {

  

for ( let key in obj ) {

  

if ( obj[key] instanceof Array ) {// obj[key] 是数组

// obj[key]是数组，遍历

newObj[key] = [];

kaobei(newObj[key], obj[key]);

} else if ( obj[key] instanceof Object ) { // obj[key]是对象

// obj[key]是对象，遍历

newObj[key] = {};

kaobei(newObj[key], obj[key]);

} else {

newObj[key] = obj[key];

}

  

}

  

}

  

kaobei(newObj, obj);

  

obj.message.score = 123;

  

console.log( obj, newObj );

<script>

```

* 深拷贝没有方法，自己制作一个方法

1. 遍历对象，如果值是数组和数组，就递归，再次调用此函数。

2. 然后如果不是对象和数组，就和浅拷贝一样，重新赋值简单数据类型
  

# JS原理

## 高阶函数

>可以被当做值来对待的函数叫高阶函数，值就是变量的赋值-数据类型

### 函数表达式

```javascript

let fun=function(){

}

```

### 回调函数
* 当一个函数当做参数传递给另一个函数时，那个参数函数就是回调函数
* 回调函数不立即使用，而是等待回调
* 回调函数就是普通函数，一般用匿名函数

#### 循环定时器

* 循环函数，每隔一段时间都调用一次回调函数
* 因为执行要间隔时间，所以首次执行也会有间隔
-  定时器的本质，就是在指定时间后将函数添加到消息队列中，但是如果函数执行的速度比较慢，它是无法确保每次执行的间隔都是一样的。所以一般使用延时定时器。
```javascript

let timer = setInterval(回调函数，间隔时间)； //会返回这个定时器的标识，可以传给结束定时器

clearInterval（timer） //传入指定定时器标识，结束定时器

```

#### 延时定时器

* 让回调函数延迟执行，只执行一次
* 每一次调用生成新的延迟器

```javascript

 let timer = setTimeout(回调函数，等待的毫秒)；//会返回这个定时器的标识，可以传给结束定时器

clearTimeout(回调函数id号)； //传入指定定时器标识，结束定时器

```

#### 监听函数

```javascript

addEventListener(type，回调函数)

```

### 日期函数

#### 创建日期函数

```javascript

var d = new Date(); --当前日期

var d = new Date("02/19/2022 20:19:00"); m/d/y h:m:s --指定的时间

var d = new Date().toLocaleString() --当前的时间

```

#### 日期函数方法

```javascript

var d = new Date();

d.getDate(); --当前几号。

d.getDay();--当前周几。 0是周日。

d.getMouth();--当前月份，0为一月。

d.getFullYear(); -- 当前年份

```

#### 时间戳

>时间戳是毫秒数，1000毫秒=1s，格林威治时间到现在的毫秒树

```javascript

获得时间戳的方法

d.getTime(); --可以传其他时间

+new Date(); --推荐的写法

Date.now() --只能获得当前的时间

```

### 立即执行函数

>创建独立作用域，变量为局部变量，避免命名冲突,可以传实参，可以命名

* 第一种写法(function(){})()；

* 第二种写法(function(){}())；

### 递归函数

* 自己调用自己就是递归函数

* 递归函数一定要加退出条件

```javascript

let num = 0

function fun() {

num++

console.log(111)

fun()

}

fun()

```

## 编程理论

### 排他思想

* 干掉所有人，然后恢复自己

#### 排他思想升级

* 选中那个唯一的类，干掉，然后给自己添加

### js执行机制

#### 事件循环（EventLoop）

>JavaScript 主线程==调用栈==执行同步任务，同时从“任务队列”中读取异步任务的回调函数，放到==调用栈==中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为 EventLoop（事件循环）。

==JS的整个执行过程，其实就是函数的执行过程，普通函数在主线程同步执行，高阶函数进入消息对列异步执行。==

调用栈（call stack）
- 栈，是一种数据结构，特点：后进先出
- 函数在每次执行时，都会产生一个执行环境
- 执行环境负责存储函数执行时产生的一切数据
- 调用栈负责存储函数的执行环境（所有函数最终都是在调用栈里执行）
- 当一个函数被调用时，它的执行环境会作为一个栈帧插入到调用栈的栈顶，函数执行完毕其栈帧会自动从栈中弹出。


#### 同步任务

> 主线程的任务，会按照从上到下依次去执行，在执行的过程中，同步任务会进入调用栈，遵循先进后出的原则依次执行，直到所有同步任务全部弹出调用栈。

- 同步任务主要包括：普通函数
- 当同步任务的函数被执行调用时，首先进入调用栈的就是全局对象window，然后函数后作为栈帧插入栈顶，如果函数里嵌套了函数，嵌套函数执行也会作为栈帧插入栈顶。当嵌套函数执行完成，它的栈帧会弹出调用栈，当函数执行完成，函数的栈帧也会弹出调用栈，最后全局对象也会弹出。
- 最上层的栈帧总是正在执行的函数。
![[Pasted image 20221008131448.png]]

==总结： 可以看出，因为函数执行完毕就会弹出调用栈，当出现多个栈帧时，就必然存在嵌套的函数。==

#### 异步任务
* 异步任务主要是耗时任务：比如回调函数，定时器等， 请求的返回。
* 异步任务由 JavaScript 委托给宿主环境进行预执行；
- 当异步任务在宿主环境预执行完成后， 异步任务进入消息队列排队，先执行完毕的任务先进入消息对列；
- 然后通知 JavaScript 主线程提取消息对列中的回调，执行异步任务的回调函数。

消息队列
- 消息队列负责存储将要执行的回调函数，执行先进先出的原则。
- 事件触发后，JS引擎是将==事件响应函数==插入到消息队列中排队。
- 如果调用栈中还存在一些还没有执行完的代码。要等调用栈中执行的代码完成后，才能从消息对列中提取。

![[Pasted image 20221008135339.png]]

==注意：从消息对列可以看出，异步任务一定要等调用栈没有函数执行了才会提取，也就是说当调用栈还有函数执行时，像循环定时器，不断异步调取的定时器，可能会有延迟。==

##### 异步任务的宏任务和微任务
- 不同的函数调用分为宏任务， 和微任务。 宏任务依次执行， 每次执行完宏任务就会检查是否还有微任务， 有微任务的话就先执行微任务， 然后再执行宏任务。
- 因为主线程任务 总是先执行， 所以就可以只考虑异步任务， 当异步任务进入消息对列时， 判断是宏任务还是微任务，就可以先后执行
- 宏任务（macrotask）
	1. 发送 Ajax 请求（请求发送是同步的， 所以也是宏任务，发送返回的结果是异步的）
	2. setTimeout、setInterval、
	3. 文件操作
	4. 其它宏任务
	5. 主线程任务
- 微任务（microtask）
	1. Promise.then、.catch 和 .finally请求的结果返回是异步的微任务
	2. process.nextTick
	3. 其它微任务
![[Pasted image 20220619003037.png]]
>每一个宏任务执行完之后，都会检查是否存在待执行的微任务，
如果有，则执行完所有微任务之后，再继续执行下一个宏任务。
- 同步任务 > 微任务 > 宏任务。

#### 执行
1. 同步任务由 JavaScript 主线程次序执行
2. 异步任务委托给宿主环境执行
3. 已完成的异步任务对应的回调函数，会被加入到消息队列中等待执行
4. JavaScript 主线程的执行栈被清空后，会读取任务队列中的回调函数，次序执行
![[Pasted image 20220619001042 1.png]]


### 浏览器机制

1. 解析HTML，生成dom树

2. 同时解析css，生成样式规则

3. 根据dom树和样式规则生成渲染树

4. 进行布局Layout（回流/重排）:根据生成的渲染树，得到节点几何信息（大小，位置），就是渲染几何布局

5. 进行绘制Painting（重绘）：根据布局得到的信息进行整个页面的绘制

6. display：展示页面


#### 浏览器的优化
> 浏览器会自己优化重绘和重排， 它会自动在某一个节点自己重新渲染页面， 然后顺便进行重绘重排。浏览器会维护1个队列，把所有会引起重排、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个`批处理`。

- 渲染flush队列的时机主要有：
	1. 宏任务结束， 下一个宏任务开始时
	2. 当flush队列满了
- 但是有些时候， 浏览器也会触发渲染flush对列机制
	1.  offsetTop, offsetLeft, offsetWidth, offsetHeight （读取也会）
	2.  scrollTop/Left/Width/Height （读取也会）
	3.  clientTop/Left/Width/Height （读取也会）
	4.  请求了getComputedStyle()
## 正则表达式

>匹配字符串中字符表达的模式

>正则表达式在javascript里是一个对象

### 语法

```javascript

// 定义表达式

let reg = /a(b)c$/i //  /表达式/修饰符

// 检查匹配

1. reg.test('我们大家一起学前端') --true/false

2. reg.exec('我们大家一起学前端') --返回数组
//0索引是匹配到的值， 1索引为匹配开始的索引， 2索引为匹配的字符串
//当给表达规则添加括号，表示分组，可以从1索引开始，获取匹配的分组里面的值。
//此方法一次只能获取一个，每调用一次就匹配下一个，需要遍历，匹配不到就返回null
```

```js
//RegExp正则表达式构造函数  （当匹配模式为数据变量时）
//参数1： 匹配模式字符串，会把数据变量变为匹配字符串传入正则
//参数2： 匹配模式，要写在字符串中
const res = new RegExp(this.str, 'gi')

```
### 元字符

>拥有特殊含义的字符，快捷的书写字符
1. /abc/
>规则字符，用来匹配字符的规则字符。

#### 边界符

>提示字符所处的位置，以什么开头^，以什么结尾$

1. /^a/ 以a开头

2. /a$/ 以a结尾

3. /^a$/ 精确匹配，只能有a

#### 量词

>设定某个模式出现的次数，只能影响前面的一个字符,但是可以用（）进行分组

1. /a*/ 重复零次，或更多次 n>=0

2. /(ab)+/ 重复一次或者更多次 n>=1

3. /a?/ 出现零次或者一次 n=0|n=1

4. /a{n}/ 重复n次

5. /a{n,}/ 重复>=n次

6. /a{n,m}/ 重复n～m次

#### 字符集

>匹配字符集合，多选一，只能选一个

1. /[abc]/   选其中一个

2. /[a-zA-Z]/   选其中一个

3. /[a-zA-Z0-9-_] 其中选一个

4. /[ ^a-z]/ 匹配除了小写字母以外的字符，取反，有就行

5. /./ 匹配除换行符（\n）以外的单个字符


### 其他字符集
\w 任意的单词字符 [A-Za-z0-9_]

\W 除了单词字符 [ ^A-Za-z0-9_]

\d 任意数字 [0-9]

\D 除了数字 [ ^0-9]

\s 空格

\S 除了空格

\b 单词边界

\B 除了单词边界

### 修饰符
* /表达式/修饰符

1. /a/i 表示检查匹配时字符不区分大小写

2. /a/g 表示检查匹配所有满足正则表达式的结果，因为正常只检查匹配一个

### 字符串的正则方法

str.replace(正则,  ’替换的文本‘)  --根据正则替换字符串内容
str.split(正则)     --根据正则对一个字符串进行拆分成数组
str.search(正则)     --根据正则搜索出匹配的内容第一次出现的位置索引
str.match(正则）  --根据正则匹配符合要求的内容，返回所有符合要求元素，封装成数组
str.matchAll()       -- 根据正则表达式去匹配字符串中符合要求的内容(必须设置g 全局匹配)，它返回的是一个迭代器

## 插件

### swiper

1. 自建一个盒子，装内容

2. 引用swiper-bundle.min.js和swiper-bundle.min.css

3. 去网页寻找模板然后查看代码

4. 复制HTML结构，css样式，js初始化

  


## 本地存储

1. 数据存储在浏览器中

2. 刷新不会消失

3. 容量大，sessionstorage/localStorage 5M

### localStorage

1. 声明周期永久生效

2. 可以多个窗口共享（同一浏览器）

3. 以键值对的形式储存

#### 存储基本数据

```javascript

// 值只能是字符串

localStorage.setItem('键'， '值')

```

##### 存储复杂数据类型（对象）

* 本地存储只能存字符串，需要将复杂数据类型变为JSON字符串

```javascript

// 将值由对象转换为JSON字符串

localStorage.setItem('obj'， JSON.stringify(obj))

```

#### 提取基本数据

```javascript

localStorage.getItem('键')

```

##### 提取复杂数据类型（对象）

```javascript

// 提取到的为JSON字符串，最后要在转换一下

JSON.parse(localStorage.getItem('obj'))

```

#### 删除数据

```javascript

localStorage.removeItem('键')

```

  

# WebAPI
>Web API中定义了非常多的对象，通过这些对象可以完成对网页的各种操作（添加删除元素、发送请求、操作浏览器等）。这些对象又分为BOM，和DOM。

## BOM浏览器对象模型
>- BOM为我们提供了一组对象，通过这组对象可以完成对浏览器的各种操作

### window对象
* window是浏览器内置的全局对象，代表浏览器窗口。
* window对象下有navigator、location、history、screen4个属性，即所谓的浏览器对象模型BOM
- DOM对象也是作为window对象的属性保存的，document作为window的又一属性，是DOM的入口。

 常见window的属性与方法：

```javascript

window.innerWidth --窗口宽度

alert("sdsad")--写在警告弹窗上

console.log("str")--写在工作台上

prompt("str")弹出一个提示框可以输入

console.time()计时器开启 console.timeEnd()计时器关闭

confirm("wenzi");弹出确认框。确认true，取消，false

```

#### location对象
>表示的是浏览器地址栏的信息

常见属性和方法：

```javascript
//可以直接将location的值修改为一个新的地址，这样会使得网页发生跳转
location.href --整个url地址,赋值可以实现地址的跳转
location.host --返回地址中的主机
location.search --返回地址中的参数，?后面的部分
location.hash --返回地址中的hash值，#后面的部分
location.assign(url)； --可以跳转页面，记录页面历史（可后退），也叫重定向页面
location.replace()； --替换当前页面，不记录页面历史
location.reload()； --重新加载页面，有本地缓存。 值为true，表示强制刷新F5，不用本地缓存，网上拉取

```

#### navigator对象

>Navigator —— 浏览器的对象（可以用来识别浏览器），该对象记录了浏览器自身的相关信息

常见属性和方法：
- navigator.userAgent 返回一个用来描述浏览器信息的字符串
* navigator.userAgent.match --客户端发送服务端的信息

#### history对象

>控制浏览器的前进后退。

1. history.back()  - 回退按钮

2. history.forward()  - 前进按钮

3. history.go()； - 可以向前跳转也可以向后跳转 如：1， 2，-1，-2


## DOM文档对象模型
>DOM，全称Document Object Model，中文翻译为文档对象模型。DOM属于Web API的一部分。
>D意为Document，即文档。所谓文档就是指整个网页，
>O意为Object，即对象。DOM将网页中的每一部分内容都转换为了对象，我们就可以以面向对象的方式去操作网页。
>M意为Model，即模型。模型用来表示节点对象之间的关系，也就是父子元素、祖先后代、兄弟元素等

### DOM节点
>DOM拓扑形成DOM树，把网页中的每一个部分都会转换为对象。执行增删改查，属性操作，事件操作。
每一个节点都有其不同的作用，文档节点表示整个网页，元素节点表示某个标签，文本节点表示网页中的文本内容，属性节点表示标签中的各种属性。如果从对象的结构上来讲，这些对象都有一个==共同的父类Node。==

==*元素节点nodeType=1    属性节点nodeType=2     文本nodeType=3

#### 文档节点
>Document对象代表的是整个的网页，在浏览器中它是window对象的属性，所以它也是我们操作节点的入口，通过window的document属性获取元素节点。在节点关系上，它是所有节点的祖先节点。

 document对象的原型链
>HTMLDocument -> Document -> Node -> EventTarget -> Object.prototype -> null
- 凡是在原型链上存在的对象的属性和方法都可以通过Document去调用，所以可以调用Document原型链中的方法，来获取元素节点对象。

- 部分属性：
document.documentElement --> html根元素
document.head --> head元素
document.title --> title元素
document.body --> body元素
document.links --> 获取页面中所有的超链接
document.write(); --会导致页面重绘，不好用

#### 元素节点
>元素节点属于网页标签节点，在网页中，每一个标签都是一个元素节点。DOM的操作都是建立在对==元素节点对象的读取与修改上==
>元素节点对象可以通过document的原型链上方法获取，也可以通过各个元素节点的原型链上的方法获得。

##### 通过document对象获取
1. 通过document对象来查找元素节点
	1. document.getElementById()
	- 根据id获取一个元素节点对象

	2. document.getElementsByClassName()
	- 根据元素的class属性值获取一组元素节点对象
	- 返回的是一个==类数组==对象
	- 该方法返回的结果是一个实时更新的集合
	- 当网页中新添加元素时，集合也会实时的刷新

	3. document.getElementsByTagName()
	- 根据标签名获取一组元素节点对象（类数组对象）
	- 返回的结果是可以实时更新的集合
	
	4. document.getElementsByTagName(" * ") 
	- 获取页面中所有的元素

	5. document.getElementsByName()
	- 根据name属性获取一组元素节点对象（类数组对象）
	- 返回一个实时更新的集合
	- 主要用于表单项

	6. document.querySelectorAll()
	- 根据选择器去页面中查询元素
	- 会返回一个类数组（不会实时更新）

	7. document.querySelector()
	- 根据选择器去页面中查询第一个符合条件的元素

2. 通过document对象来创建元素节点
	1. document.createElement()
	- 根据标签名创建一个元素节点对象


##### 通过元素节点对象获取
>某个div元素的原型链 ：    HTMLDivElement -> HTMLElement -> Element -> Node -> ...
 元素节点可以调用其原型链上的方法和属性，来获取其他关系节点。

- 元素节点.getElementByTagName(后代标签名);  返回当前节点指定标签名后代节点
* 元素节点.childNodes 当前节点的所有子节点（包括文本，注释等其他子节点）
* 元素节点.children 当前元素的所有子元素（不包括文本，注释等其他子节点）（常用）
* 元素节点.firstChild 当前节点的第一个子节点（包括文本，注释等其他子节点）
* 元素节点.lastChild 当前节点的最后一个子节点（包括文本，注释等其他子节点）
* 元素节点.lastElementChild 获取最后一个子元素（不包括文本，注释等其他子节点）
* 元素节点.firstElementChild 获取第一个子元素（不包括文本，注释等其他子节点）
* 元素节点.parentNode 当前节点的最近父节点
* 元素节点.previousElementSibling 当前节点的上一个兄弟节点 （不包括文本，注释等其他子节点）
* 元素节点.nextElementSibling 当前节点的下一个兄弟节点（不包括文本，注释等其他子节点）

##### 克隆元素节点对象
* node.cloneNode(布尔值); --克隆节点 （false)浅拷贝只克隆节点本身（true）就可以克隆其子节点
	- 使用 cloneNode() 方法对节点进行复制时，它会复制节点的所有特点包括各种属性(id)
	- 这个方法默认只会复制当前节点，而不会复制节点的子节点（文本节点）
	- 可以传递一个true作为参数，这样该方法也会将元素的子节点一起复制


##### 添加DOM的元素节点对象
>元素节点的原型链上有Node节点，可以用Node节点的方法把创建的，克隆的节点对象添加进DOM。
>创建，或者复制的节点，必须追加进DOM,否则无效。
==注意： 如果添加的节点对象是本身就在DOM节点中，那么就是移动，而不是添加。
* appendChild(); --父节点.appendChild(子节点); 将子节点添加到父节点的子节点最后
* insertBefore(); --父节点.insertBefore(新节点，旧节点);将指定的新节点，插入旧节点之前，必须父节点调用。
- insertAdjacentElement() --父节点.replaceChild(要添加的位置，要添加的元素);   可以向元素的任意位置添加元素 
```js
//位置参数：beforeend 标签的最后(子元素)
//afterbegin 标签的开始 （子元素）
//beforebegin 在元素的前边插入元素（兄弟元素）
//afterend 在元素的后边插入元素（兄弟元素）
list.insertAdjacentHTML("beforeend", li)
```
- insertAdjacentHTML() --父节点.replaceChild(要添加的位置，要添加的HTML);   可以向元素的任意位置添加HTML （会有XSS注入问题）

##### 修改DOM的元素节点对象
* replaceChild(); --父节点.replaceChild(新节点，旧节点);将指定的新节点，替换旧节点，必须父节点调用。
* replaceWith()；  --被替换节点.replaceWith(替换节点)   使用一个元素替换当前元素

##### 删除DOM的元素节点对象
* removeChild();   --父节点.removeChild(子节点); 删除一个子节点
 - remove()    --node.remove()       来删除当前元素

#### 文本节点
>在DOM中，网页中所有的文本内容都是文本节点对象,包括空格，换行等
可以通过元素来获取其中的文本节点对象，但是我们通常不会这么做。

==通常通过元素标签来直接修改文本节点==

1. element.textContent 获取或修改元素中的文本内容
	- 获取的是标签的原始内容： 文本内容、空格和换行
	- 添加文本内容：当字符串中有标签时，会自动对标签进行转义，变为字符串，而不是真正的标签

2. element.innerText 获取或修改元素中的文本内容
	- 获取的是css样式改变后的内容： 文本内容
	- 通过innerText去读取CSS样式，会触发网页的重排（计算CSS样式）
	- 添加文本内容：当字符串中有标签时，会自动对标签进行转义，变为字符串，而不是真正的标签          
       如：< li > --> &lt;li&gt;
	 
3. element.innerHTML 获取或修改元素中的html代码
	- 获取的内容：文本内容、html标签、空格和换行
	- 添加的内容：可以添加html代码，变为真正的html代码。
	- 添加内容时，有被xss注入的风险，（因为可以添加html代码，所以用户可以注入js标签添加脚本）

#### 属性节点
>属性在DOM也是一个对象，通常不需要获取对象而是直接通过元素即可完成对其的各种操作。


方式一：

读取：元素.属性名（注意，class属性需要使用className来读取）读取一个布尔值时，会返回true或false
修改：
	* 元素对象名.属性名 = "属性值"    `修改原生属性，例如：src href id alt title value type disabled
	* 元素对象名.className = "类名"   `修改元素类名，但是会覆盖
	* 元素对象名.className = "类名 新类名"   `添加类名
	* 元素对象名.classList.add("新类名")   `向元素中添加一个或多个class
	* 元素对象名.classList.remove("新类名")   `移除元素中的一个或多个class
	* 元素对象名.classList.toggke("新类名") `切换元素中的class,就是显示隐藏切换
	* 元素.classList.contains() `检查class
	* 元素.classList.replace() `替换class

方式二：
* 可以创建自定义属性必须加data-
* 所有的自定义属性都存放在dataset的对象里。

```javascript

元素对象名.getAttribute("data-index")

元素对象名.getAttribute("属性"); --创建属性，可以创建自定义属性

元素对象名.removeAttribute("属性"); --删除任何类型的属性

元素对象名.setAttribute("index",'值'); --修改自定义属性或者原生属性 (属性值一直是字符串，修改布尔值时不会类型转换)

元素对象名.dataset.id --获取自定义属性

元素对象名.dataset --获取所有自定义属性的对象集合

```

##### 操作CSS样式属性
1. 修改css样式
	* 元素对象名.style.样式名 = "样式值"    `修改元素css属性，只能修改、查看内联样式（名字必须驼峰命名法）
	- 通过class修改样式，详见属性节点的章节
	
2. 查看css样式
>查看样式一定要查看生效的样式，所以不能用修改内联样式的方法查看样式

- getComputedStyle()   ==只读==  `它会返回一个对象，这个对象中包含了当前元素所有的生效的样式
	- 参数：
		1. 要获取样式的对象
		2. 要获取的伪元素
	- 返回值：
		- 返回的一个对象，对象中存储了当前元素的生效样式  
	```js
	const beforeStyle = getComputedStyle(box1, "::before") //获取伪元素的所有生效的样式
	console.log(beforeStyle.color)
	```
	- ==注意：此方法返回的是带单位的样式字符串，不能直接使用。

##### 操作三大位置样式属性
- 不带单位，获取直接就能用。一般想要获取元素的位置样式，可以用它。

######  scroll属性
* 获取、修改元素滚动区域的大小
	1. 元素.scrollWidth
	2. 元素.scrollHeight
	
* 获取、修改元素滚动条的偏移量
	1. 元素.scrollTop --向上被卷去的高度
		* 获取整个页面的滚动属性 document.documentElement.scrollTop
	2. 元素.scrollLeft --向左被卷去的宽度


###### offset属性
==只读==
* 获取元素的可见框的大小（包括内容区、内边距和边框）
	1. 元素.offsetWidth
	2. 元素.offsetHeight

- 元素.offsetParent
	1. 获取元素的定位父元素
	2. 定位父元素：离当前元素最近的开启了定位的祖先元素，如果所有的元素都没有开启定位则返回body

* 获取元素相对于其定位父元素的偏移量（如果都没有定位，以window为主）
	1. 元素.offsetLeft
	2. 元素.offsetTop

- 整个页面被卷去的距离
	1. window.pageXoffset
	2. window.pageYoffset 

###### client属性
==只读==
* 获取元素内部的宽度和高度（包括内容区和内边距. 不包括滚动条）
	1. 元素.clientWidth
	2. 元素.clientHeight

* 获取边框宽度
	1. 元素.clientTop
	2. 元素.clientLeft

### DOM事件
>事件就是用户和页面之间发生的交互行为，比如：点击按钮、鼠标移动、双击按钮、敲击键盘、松开按键...
   可以通过为事件绑定响应函数（回调函数），来完成和用户之间的交互。
   事件由：1. 事件源(触发的对象)  2. 类型（事件）  3. 处理程序（函数赋值）组成。

#### 注册事件
>注册事件就是为对象绑定事件响应函数，一旦监听到事件发生，就触发响应函数。

- 注册事件：
	1. 可以直接在元素的属性中设置
	```html
 <button id="btn" onclick="alert('你点我干嘛~')">点我一下</button> 
	```
	
	2. 可以通过为元素对象的事件属性设置回调函数的形式来绑定事件（一个事件只能绑定一个响应函数）
	```js
	obj.onclick = function(){

	this.属性； --this指向obj调用者

	};

	obj.onclick = null; --移除事件

	```
	
	3. 可以通过元素addEventListener()方法来监听事件
	- 可以注册多个监听器
	* addEventListener(type，listener, [useCapture])
		1. type --事件类型字符串
		2. listener --事件处理函数
		3. useCapture --布尔值 ture 只执行事件捕获，false 执行事件冒泡

```javascript

obj.addEventListener(click, function() {

})

obj.click() --自动触发监听事件

obj.removeEventListener('click', fu1（移除函数名称）); --移除事件

```

#### 文档的加载
>网页是自上向下加载的，如果将js代码编写到网页的上边，js代码在执行时，网页DOM还没有加载完毕，这时会出现无法获取到DOM对象的情况。

如何解决这个问题：

1. 将script标签编写到body的里面的最后（执行最早）
2. 将代码编写到外部的js文件中，然后以defer的形式在head便签中进行引入（执行时机第二早，早于DOMContentLoaded）
```html
<head>
<script defer src="./script/script.js"></script>
</head>
```
3. 将代码编写到document对象的DOMContentLoaded的回调函数中（执行时机第三早）会在当前文档加载完毕之后触发
```js
document.addEventListener("DOMContentLoaded", function () {

 const btn = document.getElementById("btn")

 alert(btn)

 })
```
4. 将代码编写到window.onload的回调函数中,会在在窗口中的内容加载完毕之后才触发（执行时机最晚）
```js
 window.onload = function () {

 const btn = document.getElementById("btn")

console.log(btn)

 }
```


#### 事件对象

>事件对象是有浏览器在事件触发时所创建的对象，这个对象中封装了事件相关的各种信息，通过事件对象可以获取到事件的详细信息。比如：鼠标的坐标、键盘的按键..

- 浏览器在创建事件对象后，会将事件对象作为响应函数的参数传递，所以我们可以在事件的回调函数中定义一个形参来接收事件对象。
```javascript

// event里面传的就是关于该事件的属性，没有形参就传于argument里

obj.addEventListener(click, function(event) {

event.属性   //可以获取click独有的方法，或者公共的方法

}

```

- 每一个事件都会有自己独有的事件对象，里面有属于自己的属性方法，但是每个事件对象的原型链都有共同的祖先event，所有他们又有公共的方法。
```js
obj.addEventListener(click, function(event) {

	event.target //触发事件的对象,(在冒泡时，可以代替this)
	event.currentTarget //绑定事件的对象（同this）
	event.stopPropagation() //停止事件的冒泡传导，谁不想传递冒泡给谁传
	event.preventDefault() //取消事件的默认行为 
	event.eventPhase  //表示事件触发的阶段（1表示捕获阶段 2表示目标阶段 3表示冒泡阶段）
}
```

	
#### 事件流
- 在DOM中，事件的传播可以分为三个阶段：

	1. 捕获阶段 （由祖先元素向目标元素进行事件的捕获）（默认情况下，事件不会在捕获阶段触发）
	2. 目标阶段 （触发事件的对象）
	3. 冒泡阶段 （由目标元素向祖先元素进行事件的冒泡）

##### 事件的冒泡
- 事件的冒泡就是指事件的向上传导，从后代元素向祖先元素传导。
- 当一个元素上的某个事件被触发后，其祖先元素上的相同事件也会依次被触发。

==（冒泡是客观存在的，事件绑定事件只是外显了它的存在，例如：你点击了子元素，父元素通过冒泡也受到了点击，但是只有绑定了点击事件的元素，才会触发响应函数。）==

- 冒泡在监听器中开启，作为其第三个参数，默认为false
```js
obj.addEventListener(click, function(event) {

event.属性   //可以获取click独有的方法，或者公共的方法

}, false)
```

##### 事件的捕获
* 指事件从外向内的传导，当前元素触发事件以后，会先从当前元素最大的祖先元素开始向当前元素进行事件的捕获。
- 如果希望在捕获阶段触发事件，可以将addEventListener的第三个参数设置为true

##### 阻止事件流
* 事件对象.stopPropagation() --阻止冒泡或捕获
* 阻止冒泡向上传递。
* 阻止捕获向下传递。


#### 事件的委托

>将事件统一绑定给document(父元素也行)，这样事件触发时由于事件的冒泡，会导致document上的事件被触发，这样只绑定一次，所有的子元素也都能触发事件。

- 委派就是将本该绑定给多个元素的事件，统一绑定给document，这样可以降低代码复杂度方便维护

```js
const list = document.getElementById("list")  //获取父元素节点对象

const links = list.getElementsByTagName("a") // 获取list中的所有链接的类数组对象

document.addEventListener("click", (event) => {    //给document添加点击事件

// 在执行代码前，先来判断一下事件是由谁触发

// 检查event.target 是否在 links 中存在

// Array.from(links)或者【...links】 让类数组对象变成数组，然后用数组的方法判定谁触发的

if([...links].includes(event.target)){

alert(event.target.textContent)

}

})

```

==注意：委托事件给document元素或者父元素的时候，一定要判定触发事件的元素对象，是不是正确的元素。防止父元素误触发事件。


#### 事件类型
>WebAPI内置很多的事件类型，通过这些事件类型，可以更加方便的处理页面的交互。

1. 键盘事件
- keydown /    keyup
	- 键盘事件只能绑定给可以获取焦点的元素或者是document
- 事件对象：

resize 窗口变化（媒体查询）

click 点击

dblclick 双击

mouseenter/mouseleave 鼠标经过/离开 --只经过自身触发

contextmenu 右键菜单

selectstart 文本选中

mousemove 鼠标移动

keyup/keydown 按键抬起时/当按键按下时

keypress当按键按下时（press不识别功能键）

mouseover/out 鼠标经过/离开 --会冒泡

mouseenter/leave

鼠标经过/离开 --没有冒泡

blur 失去焦点

focus 获得焦点

input 输入值时立即触发

change 当表单值改变，并失去焦点时触发

scroll 滚动事件（一般给window/document添加）

load 加载事件 （一般给window添加，整个页面加载完毕再执行回调函数）

DOMContentLoaded dom加载事件 （一般给document添加，等整个dom树加载完，再执行）

图片对象的 onerror事件


#### 事件对象属性

* e.type --获取当前事件类型

* e.clientX --鼠标相对于浏览器可视区的x坐标

* e.clientY --鼠标相对于浏览器可视区y坐标

* e.pageX --鼠标相对于文档页面x坐标

* e.pageY --鼠标相对于文档页面y坐标

* e.key - 返回按下的哪个按键

* e.target --点击哪个元素，就返回那个元素

* e.currentTarget --谁是最终绑定事件的元素，就返回哪个元素

* e.preventDefault() --阻止默认行为事件，链接不跳转，提交不提交

* e.stopPropagation()； - 阻止冒泡行为 谁阻止给谁

# ES6
## 模块化
>JavaScript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范
- AMD 和 CMD 适用于浏览器端的 Javascript 模块化
- CommonJS 适用于服务器端的 Javascript 模块化
-  node.js 遵循了 CommonJS 的模块化规范。其中：
	- 导入其它模块使用 require() 方法
	- 模块对外共享成员使用 module.exports 对象

>太多的模块化规范给开发者增加了学习的难度与开发的成本。因此，大一统的 ES6 模块化规范诞生了！
## ES6的模块化
>ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。

 - 每个 js 文件都是一个独立的模块
 - 导入其它模块成员使用 import 关键字
 - 向外共享模块成员使用 export 关键字

>node.js使用es6模块化
1. 确保安装了 v14.15.1 或更高版本的 node.js
2. 在 package.json 的根节点中添加 "type": "module" 节点

>ES6模块化的用法

 1. 默认导出与默认导入
 2. 按需导出与按需导入
 3. 直接导入并执行模块中的代码
 
==注意==  当导入的是文件夹时（比如第三方包），默认会找寻文件夹下的dist，下的index文件。如果没有这些，就要老老实实写相对路径。

### 默认导出与默认导入
1. 默认导出
```javascript
let n1 = 10
let n2 = 20
function show() {}

export default {
  n1,
  show
}

// export default {
//   n2
// }
```
1. 默认导入
```javascript
import m1 from './01.默认导出.js'

console.log(m1)//获得一个对象，对象为export default 导出的对象
```
- 每个模块中，只允许使用唯一的一次 export default，否则会报错！
- 默认导入时的接收名称可以任意名称，只要是合法的成员名称即可
- 导出的是一个对象， 包含export default 里的元素

### 按需导出与按需导入
1. 按需导出
```javascript
export let s1 = 'aaa'
export let s2 = 'ccc'
export function say() {}

export default {
  a: 20
}
```
1. 按需导入
```javascript
import info, { s1, s2 as str2, say } from './03.按需导出.js'

console.log(s1)
console.log(str2)
console.log(say)
console.log(info)
```
- 每个模块中可以使用多次按需导出
- 按需导入的成员名称必须和按需导出的名称保持一致
- 按需导入时，可以使用 as 关键字进行重命名
- 按需导入可以和默认导入一起使用

区别：
实参上按需导出和默认导出差不多，都是为了把成员暴露出去。
但是按需导出导出的是 export 封装的变量，用{}导入。而默认导出，只导出export default 封装的对象， 导入时直接用变量接收对象。

### 全部导入
- 全部导入的意思是，可以把export封装的，和export default封装的都导入
```javascript
export let s1 = 'aaa'
export let s2 = 'ccc'
export function say() {}

export default {
  a: 20
}
```

- 全部导入
```js
import * as obj from '@/directives'//导入了 s1, s2 ,say, a, 并封装在obj的对象里
```

### 直接导入并执行模块中的代码
- 和Commonjs模块一样，导入及执行。
```javascript
import './05.直接运行模块中的代码.js'
```

## Promise
### 回调地狱
>当一个回调想使用上一个回调的返回值是，会用到里面的success方法，一层一层嵌套。多层回调函数的相互嵌套，就形成了回调地狱。套娃式编程，我传你值，你传它值...
>所以，es6推出promise 来解决回调地狱的问题。


- promise能解决回调函数嵌套问题，采用.then/.catch捕获上个promise的返回值，这样不用嵌套编程，而是自上而下的编程。
- promise是[[JS#异步|异步操作]]。回调函数能让执行同步，但是会回调地狱，但是用ansyc /await 就能解决promise异步的问题，像写同步那样去写异步。


![[Pasted image 20220613223619.png]]
- 代码耦合性太强，牵一发而动全身，难以维护
- 大量冗余的代码相互嵌套，代码的可读性变差

### Promise 的基本概念

1. Promise 是一个构造函数
	- 我们可以创建 Promise 的实例 new Promise(function(resolve, reject){}
	- new 出来的 Promise 实例对象，代表一个[[JS#异步|异步操作]]
	
2. new出来的promise实例对象里有两个参数，resolve和reject  
	- resolve()参数里面是成功的值，then捕获其中的值。then只接收resolve里面的值
	- reject() 里面是失败的值，catch捕获其中的值，如果想终止在某个执行链的位置，可以用Promise.reject(new Error())

```js

new Promise(function(resolve, reject){
resolve('1')
reject('2')
}).then(result => {

console.log(result) 
	//其中，result得到的就是resolve里面的值
}).catch(result => {
console.log(result)  //其中result得到的是reject的值
})

```


#### .then() 方法
>Promise.prototype 上包含一个 .then() 方法
- 每一次 new Promise() 构造函数得到的实例对象都可以通过原型链的方式访问到 .then() 方法，例如 p.then()
- p.then() 方法用来预先指定成功和失败的回调函数   p.then(result => { }, error => { })
- 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的

>如果上一个 .then() 方法中返回了一个新的 Promise 实例对象，则可以通过下一个 .then() 继续进行处理。通过 .then() 方法的链式调用，就解决了回调地狱的问题。

#### .catch() 方法
>Promise.prototype 上包含一个 .catch() 方法

- 用于捕获.catch()方法以上所有链式反应中出现的错误，并终止以上的所有promise进程
- 如果不希望前面的错误导致后续的 .then 无法正常执行，则可以将 .catch 的调用提前

```javascript
thenFs
  .readFile('./files/11.txt', 'utf8')
  //提前了catch方法让以下的then方法能够顺利进行
  .catch((err) => {
    console.log(err.message)
  })
  .then((r1) => {
    console.log(r1)
    return thenFs.readFile('./files/2.txt', 'utf8')
  })
  .then((r2) => {
    console.log(r2)
    return thenFs.readFile('./files/3.txt', 'utf8')
  })
```

#### Promise.all() 方法
>Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then 操作（等待机制）
- 数组中 Promise 实例的顺序，就是最终结果的顺序！
- 注意！.then(result) 存数组，就触发结构赋值，具体如下：
![[Pasted image 20220618152516.png]]

#### Promise.race() 方法
>Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的 .then 操作（赛跑机制）
![[Pasted image 20220618152726.png]]

### Promise的用法

####  顺序读取文件任务
- 用fs模块顺序读取文件
1. 用原生fs模块的回调函数，能做出按顺序读取文件，但是不易读。

![[Pasted image 20220613233453.png]]
 - 所以可以用promise调用
1. 原生的fs内置模块不支持Promise 所以要安装第三方包 npm i then-fs
```javascript
//调用 then-fs 提供的 readFile() 方法，可以异步地读取文件的内容，它的返回值是 Promise 的实例对象。因此可以调用 .then() 方法为每个 Promise 异步操作指定成功和失败之后的回调函数。
import thenFs from 'then-fs'
thenFs.readFile('./files/1.txt', 'utf8').then((r1) => {console.log(r1)})
thenFs.readFile('./files/2.txt', 'utf8').then((r2) => {console.log(r2)})
thenFs.readFile('./files/3.txt', 'utf8').then((r3) => {console.log(r3)})
//上述的代码还是无法保证文件的读取顺序
```
2. 上述的代码无法保证文件的读取顺序，Promise 支持链式调用，从而来解决回调地狱的问题
```javascript
import thenFs from 'then-fs'
thenFs
  .readFile('./files/11.txt', 'utf8')
  })
  .then((r1) => {
    console.log(r1)
    return thenFs.readFile('./files/2.txt', 'utf8')
  })
  .then((r2) => {
    console.log(r2)
    return thenFs.readFile('./files/3.txt', 'utf8')
  })
  .then((r3) => {
    console.log(r3)
  })
```
####  封装读取文件的方法
1. 方法的名称要定义为 getFile
2. 方法接收一个形参 fpath，表示要读取的文件的路径
3. 方法的返回值为 Promise 实例对象
通过 .then() 指定的成功和失败的回调函数，可以在 function 的形参中进行接收
![[Pasted image 20220618224220.png]]
```javascript
import fs from 'fs'
//创建一个函数并传入路径形参
function getFile(fpath) {
//返回一个promise对象并传入一个回调函数，写入具体执行
  return new Promise(function (resolve, reject) {    //接受.then方法传回来的回调类型的实参
    fs.readFile(fpath, 'utf8', (err, dataStr) => {
      if (err) return reject(err) //如果失败，执行失败的回调,并传入实参
      resolve(dataStr)//如果成功，执行成功的回调，并传入实参
    })
  })
}
//执行封装的方法
getFile('./files/11.txt')
  .then((r1) => {
    console.log(r1)
  })
  .catch((err) => console.log(err.message))
```


### 优缺点
- .then 链式调用的优点：解决了回调地狱的问题
- .then 链式调用的缺点：代码冗余、阅读性差、不易理解，必须通过then才能达到结果。

## async/await

>用来简化 Promise 异步操作。在 async/await 出现之前，开发者只能通过链式 .then() 的方式处理 Promise 异步操作。

- **await** 表示强制等待的意思，**await**关键字的后面要跟一个promise对象，它总是等到该promise对象resolve成功之后执行，并且会返回resolve的结果，就是把异步的promise变为同步，函数内部后面的代码强制等待。

- 由于await的强制等待，所以必须要求使用**await**的函数必须使用**async**标记， async表示该函数就是一个异步函数，不会阻塞其他执行逻辑的执行。因为await会等待，为了不影响效率，把整个函数添加async变为异步的。这样不会影响后面的code。 被async标记的函数返回的实际上也是promise对象.


```javascript
import thenFs from 'then-fs'
console.log('A')

async function getAllFile() {
  console.log('B')
  const r1 = await thenFs.readFile('./files/1.txt', 'utf8')
  console.log(r1)
  const r2 = await thenFs.readFile('./files/2.txt', 'utf8')
  console.log(r2)
  const r3 = await thenFs.readFile('./files/3.txt', 'utf8')
  console.log(r3)
  console.log('D')
}

getAllFile()
console.log('C')
//最终输出：
A   --同步
B   --同步
C   --同步
ri r2 r3  --异步
d --异步
```

- await其是就是then，捕获resolve里面的值并自动返回。
-  用try / catch   可以捕获错误的值
- 后面还可以跟。finally{} ，不论try还是catch 最后都会进finally

```js

async getCatch () {

try {

await new Promise(function (resolve, reject) {

reject(new Error('fail'))

})

alert(123)

} catch (error) {

alert(error)

}finally{


} 

}

```